{"mappings":"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","sources":["node_modules/jsonld-context-parser/lib/ContextParser.js","node_modules/relative-to-absolute-iri/index.js","node_modules/relative-to-absolute-iri/lib/Resolve.js","node_modules/jsonld-context-parser/lib/ErrorCoded.js","node_modules/jsonld-context-parser/lib/FetchDocumentLoader.js","node_modules/http-link-header/lib/link.js","node_modules/jsonld-context-parser/lib/JsonLdContextNormalized.js","node_modules/jsonld-context-parser/lib/Util.js","node_modules/canonicalize/lib/canonicalize.js","node_modules/jsonld-context-parser/lib/IDocumentLoader.js","node_modules/jsonld-context-parser/lib/JsonLdContext.js","node_modules/@webreflection/mapset/esm/index.js","node_modules/@webreflection/uparser/esm/index.js","node_modules/@webreflection/uwire/esm/index.js","node_modules/uarray/esm/index.js","node_modules/uhandlers/esm/index.js","node_modules/udomdiff/esm/index.js","node_modules/uhtml/esm/utils.js","node_modules/uhtml/esm/handlers.js","node_modules/uhtml/esm/rabbit.js","node_modules/uhtml/esm/index.js","node_modules/jsonld-context-parser/index.js","src/helpers/withLoader.ts","src/helpers/preloadPaths.ts","node_modules/ldflex/module/PathProxy.js","node_modules/ldflex/node_modules/@rdfjs/data-model/lib/BlankNode.js","node_modules/ldflex/node_modules/@rdfjs/data-model/lib/DefaultGraph.js","node_modules/ldflex/node_modules/@rdfjs/data-model/lib/fromTerm.js","node_modules/ldflex/node_modules/@rdfjs/data-model/lib/NamedNode.js","node_modules/ldflex/node_modules/@rdfjs/data-model/lib/Literal.js","node_modules/ldflex/node_modules/@rdfjs/data-model/lib/Quad.js","node_modules/ldflex/node_modules/@rdfjs/data-model/lib/Variable.js","node_modules/ldflex/node_modules/@rdfjs/data-model/lib/DataFactory.js","node_modules/ldflex/node_modules/@rdfjs/data-model/index.js","node_modules/ldflex/module/ContextProvider.js","node_modules/ldflex/module/iterableUtils.js","node_modules/ldflex/module/promiseUtils.js","node_modules/ldflex/module/valueUtils.js","node_modules/ldflex/module/AbstractPathResolver.js","node_modules/ldflex/module/JSONLDResolver.js","src/helpers/ComplexPathResolver.ts","node_modules/ldflex/module/AsyncIteratorHandler.js","node_modules/ldflex/module/handlerUtil.js","node_modules/ldflex/module/CollectionsHandler.js","node_modules/ldflex/module/DataHandler.js","node_modules/ldflex/module/MutationFunctionHandler.js","node_modules/ldflex/module/ExecuteQueryHandler.js","node_modules/ldflex/module/GetFunctionHandler.js","node_modules/ldflex/module/MutationExpressionsHandler.js","node_modules/ldflex/module/PathExpressionHandler.js","node_modules/ldflex/module/PredicateHandler.js","node_modules/ldflex/module/PredicatesHandler.js","node_modules/ldflex/module/PreloadHandler.js","node_modules/ldflex/module/PropertiesHandler.js","node_modules/ldflex/module/SortHandler.js","node_modules/ldflex/module/SparqlHandler.js","node_modules/ldflex/module/StringToLDflexHandler.js","node_modules/ldflex/module/SubjectHandler.js","node_modules/ldflex/module/SubjectsHandler.js","node_modules/ldflex/module/ThenHandler.js","node_modules/ldflex/module/ToArrayHandler.js","node_modules/ldflex/module/URIHandler.js","node_modules/ldflex/module/defaultHandlers.js","node_modules/ldflex/module/InsertFunctionHandler.js","node_modules/ldflex/module/SetFunctionHandler.js","node_modules/ldflex/module/ReplaceFunctionHandler.js","node_modules/ldflex/module/DeleteFunctionHandler.js","src/helpers/PathFactory.ts","src/helpers/FetchEngine.ts","src/helpers/PreloadHandler.ts","src/helpers/path.ts","src/helpers/createHtml.ts","demo/demo.ts","src/helpers/prefixes.ts"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.defaultExpandOptions = exports.ContextParser = void 0;\nrequire(\"cross-fetch/polyfill\");\nconst relative_to_absolute_iri_1 = require(\"relative-to-absolute-iri\");\nconst ErrorCoded_1 = require(\"./ErrorCoded\");\nconst FetchDocumentLoader_1 = require(\"./FetchDocumentLoader\");\nconst JsonLdContextNormalized_1 = require(\"./JsonLdContextNormalized\");\nconst Util_1 = require(\"./Util\");\n// tslint:disable-next-line:no-var-requires\nconst canonicalizeJson = require('canonicalize');\n/**\n * Parses JSON-LD contexts.\n */\nclass ContextParser {\n    constructor(options) {\n        options = options || {};\n        this.documentLoader = options.documentLoader || new FetchDocumentLoader_1.FetchDocumentLoader();\n        this.documentCache = {};\n        this.validateContext = !options.skipValidation;\n        this.expandContentTypeToBase = !!options.expandContentTypeToBase;\n        this.remoteContextsDepthLimit = options.remoteContextsDepthLimit || 32;\n        this.redirectSchemaOrgHttps = 'redirectSchemaOrgHttps' in options ? !!options.redirectSchemaOrgHttps : true;\n    }\n    /**\n     * Validate the given @language value.\n     * An error will be thrown if it is invalid.\n     * @param value An @language value.\n     * @param {boolean} strictRange If the string value should be strictly checked against a regex.\n     * @param {string} errorCode The error code to emit on errors.\n     * @return {boolean} If validation passed.\n     *                   Can only be false if strictRange is false and the string value did not pass the regex.\n     */\n    static validateLanguage(value, strictRange, errorCode) {\n        if (typeof value !== 'string') {\n            throw new ErrorCoded_1.ErrorCoded(`The value of an '@language' must be a string, got '${JSON.stringify(value)}'`, errorCode);\n        }\n        if (!Util_1.Util.REGEX_LANGUAGE_TAG.test(value)) {\n            if (strictRange) {\n                throw new ErrorCoded_1.ErrorCoded(`The value of an '@language' must be a valid language tag, got '${JSON.stringify(value)}'`, errorCode);\n            }\n            else {\n                return false;\n            }\n        }\n        return true;\n    }\n    /**\n     * Validate the given @direction value.\n     * An error will be thrown if it is invalid.\n     * @param value An @direction value.\n     * @param {boolean} strictValues If the string value should be strictly checked against a regex.\n     * @return {boolean} If validation passed.\n     *                   Can only be false if strictRange is false and the string value did not pass the regex.\n     */\n    static validateDirection(value, strictValues) {\n        if (typeof value !== 'string') {\n            throw new ErrorCoded_1.ErrorCoded(`The value of an '@direction' must be a string, got '${JSON.stringify(value)}'`, ErrorCoded_1.ERROR_CODES.INVALID_BASE_DIRECTION);\n        }\n        if (!Util_1.Util.REGEX_DIRECTION_TAG.test(value)) {\n            if (strictValues) {\n                throw new ErrorCoded_1.ErrorCoded(`The value of an '@direction' must be 'ltr' or 'rtl', got '${JSON.stringify(value)}'`, ErrorCoded_1.ERROR_CODES.INVALID_BASE_DIRECTION);\n            }\n            else {\n                return false;\n            }\n        }\n        return true;\n    }\n    /**\n     * Add an @id term for all @reverse terms.\n     * @param {IJsonLdContextNormalizedRaw} context A context.\n     * @return {IJsonLdContextNormalizedRaw} The mutated input context.\n     */\n    idifyReverseTerms(context) {\n        for (const key of Object.keys(context)) {\n            const value = context[key];\n            if (value && typeof value === 'object') {\n                if (value['@reverse'] && !value['@id']) {\n                    if (typeof value['@reverse'] !== 'string' || Util_1.Util.isValidKeyword(value['@reverse'])) {\n                        throw new ErrorCoded_1.ErrorCoded(`Invalid @reverse value, must be absolute IRI or blank node: '${value['@reverse']}'`, ErrorCoded_1.ERROR_CODES.INVALID_IRI_MAPPING);\n                    }\n                    value['@id'] = value['@reverse'];\n                    if (Util_1.Util.isPotentialKeyword(value['@reverse'])) {\n                        delete value['@reverse'];\n                    }\n                    else {\n                        value['@reverse'] = true;\n                    }\n                }\n            }\n        }\n        return context;\n    }\n    /**\n     * Expand all prefixed terms in the given context.\n     * @param {IJsonLdContextNormalizedRaw} context A context.\n     * @param {boolean} expandContentTypeToBase If @type inside the context may be expanded\n     *                                          via @base if @vocab is set to null.\n     */\n    expandPrefixedTerms(context, expandContentTypeToBase) {\n        const contextRaw = context.getContextRaw();\n        for (const key of Object.keys(contextRaw)) {\n            // Only expand allowed keys\n            if (Util_1.Util.EXPAND_KEYS_BLACKLIST.indexOf(key) < 0 && !Util_1.Util.isReservedInternalKeyword(key)) {\n                // Error if we try to alias a keyword to something else.\n                const keyValue = contextRaw[key];\n                if (Util_1.Util.isPotentialKeyword(key) && Util_1.Util.ALIAS_DOMAIN_BLACKLIST.indexOf(key) >= 0) {\n                    if (key !== '@type' || typeof contextRaw[key] === 'object'\n                        && !(contextRaw[key]['@protected'] || contextRaw[key]['@container'] === '@set')) {\n                        throw new ErrorCoded_1.ErrorCoded(`Keywords can not be aliased to something else.\nTried mapping ${key} to ${JSON.stringify(keyValue)}`, ErrorCoded_1.ERROR_CODES.KEYWORD_REDEFINITION);\n                    }\n                }\n                // Error if we try to alias to an illegal keyword\n                if (Util_1.Util.ALIAS_RANGE_BLACKLIST.indexOf(Util_1.Util.getContextValueId(keyValue)) >= 0) {\n                    throw new ErrorCoded_1.ErrorCoded(`Aliasing to certain keywords is not allowed.\nTried mapping ${key} to ${JSON.stringify(keyValue)}`, ErrorCoded_1.ERROR_CODES.INVALID_KEYWORD_ALIAS);\n                }\n                // Error if this term was marked as prefix as well\n                if (keyValue && Util_1.Util.isPotentialKeyword(Util_1.Util.getContextValueId(keyValue))\n                    && keyValue['@prefix'] === true) {\n                    throw new ErrorCoded_1.ErrorCoded(`Tried to use keyword aliases as prefix: '${key}': '${JSON.stringify(keyValue)}'`, ErrorCoded_1.ERROR_CODES.INVALID_TERM_DEFINITION);\n                }\n                // Loop because prefixes might be nested\n                while (Util_1.Util.isPrefixValue(contextRaw[key])) {\n                    const value = contextRaw[key];\n                    let changed = false;\n                    if (typeof value === 'string') {\n                        contextRaw[key] = context.expandTerm(value, true);\n                        changed = changed || value !== contextRaw[key];\n                    }\n                    else {\n                        const id = value['@id'];\n                        const type = value['@type'];\n                        // If @id is missing, don't allow @id to be added if @prefix: true and key not being a valid IRI.\n                        const canAddIdEntry = !('@prefix' in value) || Util_1.Util.isValidIri(key);\n                        if ('@id' in value) {\n                            // Use @id value for expansion\n                            if (id !== undefined && id !== null && typeof id === 'string') {\n                                contextRaw[key]['@id'] = context.expandTerm(id, true);\n                                changed = changed || id !== contextRaw[key]['@id'];\n                            }\n                        }\n                        else if (!Util_1.Util.isPotentialKeyword(key) && canAddIdEntry) {\n                            // Add an explicit @id value based on the expanded key value\n                            const newId = context.expandTerm(key, true);\n                            if (newId !== key) {\n                                // Don't set @id if expansion failed\n                                contextRaw[key]['@id'] = newId;\n                                changed = true;\n                            }\n                        }\n                        if (type && typeof type === 'string' && type !== '@vocab'\n                            && (!value['@container'] || !value['@container']['@type'])\n                            && canAddIdEntry) {\n                            // First check @vocab, then fallback to @base\n                            contextRaw[key]['@type'] = context.expandTerm(type, true);\n                            if (expandContentTypeToBase && type === contextRaw[key]['@type']) {\n                                contextRaw[key]['@type'] = context.expandTerm(type, false);\n                            }\n                            changed = changed || type !== contextRaw[key]['@type'];\n                        }\n                    }\n                    if (!changed) {\n                        break;\n                    }\n                }\n            }\n        }\n    }\n    /**\n     * Normalize the @language entries in the given context to lowercase.\n     * @param {IJsonLdContextNormalizedRaw} context A context.\n     * @param {IParseOptions} parseOptions The parsing options.\n     */\n    normalize(context, { processingMode, normalizeLanguageTags }) {\n        // Lowercase language keys in 1.0\n        if (normalizeLanguageTags || processingMode === 1.0) {\n            for (const key of Object.keys(context)) {\n                if (key === '@language' && typeof context[key] === 'string') {\n                    context[key] = context[key].toLowerCase();\n                }\n                else {\n                    const value = context[key];\n                    if (value && typeof value === 'object') {\n                        if (typeof value['@language'] === 'string') {\n                            value['@language'] = value['@language'].toLowerCase();\n                        }\n                    }\n                }\n            }\n        }\n    }\n    /**\n     * Convert all @container strings and array values to hash-based values.\n     * @param {IJsonLdContextNormalizedRaw} context A context.\n     */\n    containersToHash(context) {\n        for (const key of Object.keys(context)) {\n            const value = context[key];\n            if (value && typeof value === 'object') {\n                if (typeof value['@container'] === 'string') {\n                    value['@container'] = { [value['@container']]: true };\n                }\n                else if (Array.isArray(value['@container'])) {\n                    const newValue = {};\n                    for (const containerValue of value['@container']) {\n                        newValue[containerValue] = true;\n                    }\n                    value['@container'] = newValue;\n                }\n            }\n        }\n    }\n    /**\n     * Normalize and apply context-levevl @protected terms onto each term separately.\n     * @param {IJsonLdContextNormalizedRaw} context A context.\n     * @param {number} processingMode The processing mode.\n     */\n    applyScopedProtected(context, { processingMode }) {\n        if (processingMode && processingMode >= 1.1) {\n            if (context['@protected']) {\n                for (const key of Object.keys(context)) {\n                    if (Util_1.Util.isReservedInternalKeyword(key)) {\n                        continue;\n                    }\n                    if (!Util_1.Util.isPotentialKeyword(key) && !Util_1.Util.isTermProtected(context, key)) {\n                        const value = context[key];\n                        if (value && typeof value === 'object') {\n                            if (!('@protected' in context[key])) {\n                                // Mark terms with object values as protected if they don't have an @protected: false annotation\n                                context[key]['@protected'] = true;\n                            }\n                        }\n                        else {\n                            // Convert string-based term values to object-based values with @protected: true\n                            context[key] = {\n                                '@id': value,\n                                '@protected': true,\n                            };\n                        }\n                    }\n                }\n                delete context['@protected'];\n            }\n        }\n    }\n    /**\n     * Check if the given context inheritance does not contain any overrides of protected terms.\n     * @param {IJsonLdContextNormalizedRaw} contextBefore The context that may contain some protected terms.\n     * @param {IJsonLdContextNormalizedRaw} contextAfter A new context that is being applied on the first one.\n     * @param {IExpandOptions} expandOptions Options that are needed for any expansions during this validation.\n     */\n    validateKeywordRedefinitions(contextBefore, contextAfter, expandOptions) {\n        for (const key of Object.keys(contextAfter)) {\n            if (Util_1.Util.isTermProtected(contextBefore, key)) {\n                // The entry in the context before will always be in object-mode\n                // If the new entry is in string-mode, convert it to object-mode\n                // before checking if it is identical.\n                if (typeof contextAfter[key] === 'string') {\n                    const isPrefix = Util_1.Util.isSimpleTermDefinitionPrefix(contextAfter[key], expandOptions);\n                    contextAfter[key] = { '@id': contextAfter[key] };\n                    // If the simple term def was a prefix, explicitly mark the term as a prefix in the expanded term definition,\n                    // because otherwise we loose this information due to JSON-LD interpreting prefixes differently\n                    // in simple vs expanded term definitions.\n                    if (isPrefix) {\n                        contextAfter[key]['@prefix'] = true;\n                        contextBefore[key]['@prefix'] = true; // Also on before, to make sure the next step still considers them ==\n                    }\n                }\n                // Convert term values to strings for each comparison\n                const valueBefore = canonicalizeJson(contextBefore[key]);\n                // We modify this deliberately,\n                // as we need it for the value comparison (they must be identical modulo '@protected')),\n                // and for the fact that this new value will override the first one.\n                contextAfter[key]['@protected'] = true;\n                const valueAfter = canonicalizeJson(contextAfter[key]);\n                // Error if they are not identical\n                if (valueBefore !== valueAfter) {\n                    throw new ErrorCoded_1.ErrorCoded(`Attempted to override the protected keyword ${key} from ${JSON.stringify(Util_1.Util.getContextValueId(contextBefore[key]))} to ${JSON.stringify(Util_1.Util.getContextValueId(contextAfter[key]))}`, ErrorCoded_1.ERROR_CODES.PROTECTED_TERM_REDEFINITION);\n                }\n            }\n        }\n    }\n    /**\n     * Validate the entries of the given context.\n     * @param {IJsonLdContextNormalizedRaw} context A context.\n     * @param {IParseOptions} options The parse options.\n     */\n    validate(context, { processingMode }) {\n        for (const key of Object.keys(context)) {\n            // Ignore reserved internal keywords.\n            if (Util_1.Util.isReservedInternalKeyword(key)) {\n                continue;\n            }\n            // Do not allow empty term\n            if (key === '') {\n                throw new ErrorCoded_1.ErrorCoded(`The empty term is not allowed, got: '${key}': '${JSON.stringify(context[key])}'`, ErrorCoded_1.ERROR_CODES.INVALID_TERM_DEFINITION);\n            }\n            const value = context[key];\n            const valueType = typeof value;\n            // First check if the key is a keyword\n            if (Util_1.Util.isPotentialKeyword(key)) {\n                switch (key.substr(1)) {\n                    case 'vocab':\n                        if (value !== null && valueType !== 'string') {\n                            throw new ErrorCoded_1.ErrorCoded(`Found an invalid @vocab IRI: ${value}`, ErrorCoded_1.ERROR_CODES.INVALID_VOCAB_MAPPING);\n                        }\n                        break;\n                    case 'base':\n                        if (value !== null && valueType !== 'string') {\n                            throw new ErrorCoded_1.ErrorCoded(`Found an invalid @base IRI: ${context[key]}`, ErrorCoded_1.ERROR_CODES.INVALID_BASE_IRI);\n                        }\n                        break;\n                    case 'language':\n                        if (value !== null) {\n                            ContextParser.validateLanguage(value, true, ErrorCoded_1.ERROR_CODES.INVALID_DEFAULT_LANGUAGE);\n                        }\n                        break;\n                    case 'version':\n                        if (value !== null && valueType !== 'number') {\n                            throw new ErrorCoded_1.ErrorCoded(`Found an invalid @version number: ${value}`, ErrorCoded_1.ERROR_CODES.INVALID_VERSION_VALUE);\n                        }\n                        break;\n                    case 'direction':\n                        if (value !== null) {\n                            ContextParser.validateDirection(value, true);\n                        }\n                        break;\n                    case 'propagate':\n                        if (processingMode === 1.0) {\n                            throw new ErrorCoded_1.ErrorCoded(`Found an illegal @propagate keyword: ${value}`, ErrorCoded_1.ERROR_CODES.INVALID_CONTEXT_ENTRY);\n                        }\n                        if (value !== null && valueType !== 'boolean') {\n                            throw new ErrorCoded_1.ErrorCoded(`Found an invalid @propagate value: ${value}`, ErrorCoded_1.ERROR_CODES.INVALID_PROPAGATE_VALUE);\n                        }\n                        break;\n                }\n                // Don't allow keywords to be overridden\n                if (Util_1.Util.isValidKeyword(key) && Util_1.Util.isValidKeyword(Util_1.Util.getContextValueId(value))) {\n                    throw new ErrorCoded_1.ErrorCoded(`Illegal keyword alias in term value, found: '${key}': '${Util_1.Util\n                        .getContextValueId(value)}'`, ErrorCoded_1.ERROR_CODES.KEYWORD_REDEFINITION);\n                }\n                continue;\n            }\n            // Otherwise, consider the key a term\n            if (value !== null) {\n                switch (valueType) {\n                    case 'string':\n                        if (Util_1.Util.getPrefix(value, context) === key) {\n                            throw new ErrorCoded_1.ErrorCoded(`Detected cyclical IRI mapping in context entry: '${key}': '${JSON\n                                .stringify(value)}'`, ErrorCoded_1.ERROR_CODES.CYCLIC_IRI_MAPPING);\n                        }\n                        if (Util_1.Util.isValidIriWeak(key)) {\n                            if (value === '@type') {\n                                throw new ErrorCoded_1.ErrorCoded(`IRIs can not be mapped to @type, found: '${key}': '${value}'`, ErrorCoded_1.ERROR_CODES.INVALID_IRI_MAPPING);\n                            }\n                            else if (Util_1.Util.isValidIri(value) && value !== new JsonLdContextNormalized_1.JsonLdContextNormalized(context).expandTerm(key)) {\n                                throw new ErrorCoded_1.ErrorCoded(`IRIs can not be mapped to other IRIs, found: '${key}': '${value}'`, ErrorCoded_1.ERROR_CODES.INVALID_IRI_MAPPING);\n                            }\n                        }\n                        break;\n                    case 'object':\n                        if (!Util_1.Util.isCompactIri(key) && !('@id' in value)\n                            && (value['@type'] === '@id' ? !context['@base'] : !context['@vocab'])) {\n                            throw new ErrorCoded_1.ErrorCoded(`Missing @id in context entry: '${key}': '${JSON.stringify(value)}'`, ErrorCoded_1.ERROR_CODES.INVALID_IRI_MAPPING);\n                        }\n                        for (const objectKey of Object.keys(value)) {\n                            const objectValue = value[objectKey];\n                            if (!objectValue) {\n                                continue;\n                            }\n                            switch (objectKey) {\n                                case '@id':\n                                    if (Util_1.Util.isValidKeyword(objectValue)\n                                        && objectValue !== '@type' && objectValue !== '@id' && objectValue !== '@graph') {\n                                        throw new ErrorCoded_1.ErrorCoded(`Illegal keyword alias in term value, found: '${key}': '${JSON.stringify(value)}'`, ErrorCoded_1.ERROR_CODES.INVALID_IRI_MAPPING);\n                                    }\n                                    if (Util_1.Util.isValidIriWeak(key)) {\n                                        if (objectValue === '@type') {\n                                            throw new ErrorCoded_1.ErrorCoded(`IRIs can not be mapped to @type, found: '${key}': '${JSON.stringify(value)}'`, ErrorCoded_1.ERROR_CODES.INVALID_IRI_MAPPING);\n                                        }\n                                        else if (Util_1.Util.isValidIri(objectValue)\n                                            && objectValue !== new JsonLdContextNormalized_1.JsonLdContextNormalized(context).expandTerm(key)) {\n                                            throw new ErrorCoded_1.ErrorCoded(`IRIs can not be mapped to other IRIs, found: '${key}': '${JSON.stringify(value)}'`, ErrorCoded_1.ERROR_CODES.INVALID_IRI_MAPPING);\n                                        }\n                                    }\n                                    if (typeof objectValue !== 'string') {\n                                        throw new ErrorCoded_1.ErrorCoded(`Detected non-string @id in context entry: '${key}': '${JSON.stringify(value)}'`, ErrorCoded_1.ERROR_CODES.INVALID_IRI_MAPPING);\n                                    }\n                                    if (Util_1.Util.getPrefix(objectValue, context) === key) {\n                                        throw new ErrorCoded_1.ErrorCoded(`Detected cyclical IRI mapping in context entry: '${key}': '${JSON\n                                            .stringify(value)}'`, ErrorCoded_1.ERROR_CODES.CYCLIC_IRI_MAPPING);\n                                    }\n                                    break;\n                                case '@type':\n                                    if (value['@container'] === '@type' && objectValue !== '@id' && objectValue !== '@vocab') {\n                                        throw new ErrorCoded_1.ErrorCoded(`@container: @type only allows @type: @id or @vocab, but got: '${key}': '${objectValue}'`, ErrorCoded_1.ERROR_CODES.INVALID_TYPE_MAPPING);\n                                    }\n                                    if (typeof objectValue !== 'string') {\n                                        throw new ErrorCoded_1.ErrorCoded(`The value of an '@type' must be a string, got '${JSON.stringify(valueType)}'`, ErrorCoded_1.ERROR_CODES.INVALID_TYPE_MAPPING);\n                                    }\n                                    if (objectValue !== '@id' && objectValue !== '@vocab'\n                                        && (processingMode === 1.0 || objectValue !== '@json')\n                                        && (processingMode === 1.0 || objectValue !== '@none')\n                                        && (objectValue[0] === '_' || !Util_1.Util.isValidIri(objectValue))) {\n                                        throw new ErrorCoded_1.ErrorCoded(`A context @type must be an absolute IRI, found: '${key}': '${objectValue}'`, ErrorCoded_1.ERROR_CODES.INVALID_TYPE_MAPPING);\n                                    }\n                                    break;\n                                case '@reverse':\n                                    if (typeof objectValue === 'string' && value['@id'] && value['@id'] !== objectValue) {\n                                        throw new ErrorCoded_1.ErrorCoded(`Found non-matching @id and @reverse term values in '${key}':\\\n'${objectValue}' and '${value['@id']}'`, ErrorCoded_1.ERROR_CODES.INVALID_REVERSE_PROPERTY);\n                                    }\n                                    if ('@nest' in value) {\n                                        throw new ErrorCoded_1.ErrorCoded(`@nest is not allowed in the reverse property '${key}'`, ErrorCoded_1.ERROR_CODES.INVALID_REVERSE_PROPERTY);\n                                    }\n                                    break;\n                                case '@container':\n                                    if (processingMode === 1.0) {\n                                        if (Object.keys(objectValue).length > 1\n                                            || Util_1.Util.CONTAINERS_1_0.indexOf(Object.keys(objectValue)[0]) < 0) {\n                                            throw new ErrorCoded_1.ErrorCoded(`Invalid term @container for '${key}' ('${Object.keys(objectValue)}') in 1.0, \\\nmust be only one of ${Util_1.Util.CONTAINERS_1_0.join(', ')}`, ErrorCoded_1.ERROR_CODES.INVALID_CONTAINER_MAPPING);\n                                        }\n                                    }\n                                    for (const containerValue of Object.keys(objectValue)) {\n                                        if (containerValue === '@list' && value['@reverse']) {\n                                            throw new ErrorCoded_1.ErrorCoded(`Term value can not be @container: @list and @reverse at the same time on '${key}'`, ErrorCoded_1.ERROR_CODES.INVALID_REVERSE_PROPERTY);\n                                        }\n                                        if (Util_1.Util.CONTAINERS.indexOf(containerValue) < 0) {\n                                            throw new ErrorCoded_1.ErrorCoded(`Invalid term @container for '${key}' ('${containerValue}'), \\\nmust be one of ${Util_1.Util.CONTAINERS.join(', ')}`, ErrorCoded_1.ERROR_CODES.INVALID_CONTAINER_MAPPING);\n                                        }\n                                    }\n                                    break;\n                                case '@language':\n                                    ContextParser.validateLanguage(objectValue, true, ErrorCoded_1.ERROR_CODES.INVALID_LANGUAGE_MAPPING);\n                                    break;\n                                case '@direction':\n                                    ContextParser.validateDirection(objectValue, true);\n                                    break;\n                                case '@prefix':\n                                    if (objectValue !== null && typeof objectValue !== 'boolean') {\n                                        throw new ErrorCoded_1.ErrorCoded(`Found an invalid term @prefix boolean in: '${key}': '${JSON.stringify(value)}'`, ErrorCoded_1.ERROR_CODES.INVALID_PREFIX_VALUE);\n                                    }\n                                    if (!('@id' in value) && !Util_1.Util.isValidIri(key)) {\n                                        throw new ErrorCoded_1.ErrorCoded(`Invalid @prefix definition for '${key}' ('${JSON.stringify(value)}'`, ErrorCoded_1.ERROR_CODES.INVALID_TERM_DEFINITION);\n                                    }\n                                    break;\n                                case '@index':\n                                    if (processingMode === 1.0 || !value['@container'] || !value['@container']['@index']) {\n                                        throw new ErrorCoded_1.ErrorCoded(`Attempt to add illegal key to value object: '${key}': '${JSON.stringify(value)}'`, ErrorCoded_1.ERROR_CODES.INVALID_TERM_DEFINITION);\n                                    }\n                                    break;\n                                case '@nest':\n                                    if (Util_1.Util.isPotentialKeyword(objectValue) && objectValue !== '@nest') {\n                                        throw new ErrorCoded_1.ErrorCoded(`Found an invalid term @nest value in: '${key}': '${JSON.stringify(value)}'`, ErrorCoded_1.ERROR_CODES.INVALID_NEST_VALUE);\n                                    }\n                            }\n                        }\n                        break;\n                    default:\n                        throw new ErrorCoded_1.ErrorCoded(`Found an invalid term value: '${key}': '${value}'`, ErrorCoded_1.ERROR_CODES.INVALID_TERM_DEFINITION);\n                }\n            }\n        }\n    }\n    /**\n     * Apply the @base context entry to the given context under certain circumstances.\n     * @param context A context.\n     * @param options Parsing options.\n     * @param inheritFromParent If the @base value from the parent context can be inherited.\n     * @return The given context.\n     */\n    applyBaseEntry(context, options, inheritFromParent) {\n        // In some special cases, this can be a string, so ignore those.\n        if (typeof context === 'string') {\n            return context;\n        }\n        // Give priority to @base in the parent context\n        if (inheritFromParent && !('@base' in context) && options.parentContext\n            && typeof options.parentContext === 'object' && '@base' in options.parentContext) {\n            context['@base'] = options.parentContext['@base'];\n            if (options.parentContext['@__baseDocument']) {\n                context['@__baseDocument'] = true;\n            }\n        }\n        // Override the base IRI if provided.\n        if (options.baseIRI && !options.external) {\n            if (!('@base' in context)) {\n                // The context base is the document base\n                context['@base'] = options.baseIRI;\n                context['@__baseDocument'] = true;\n            }\n            else if (context['@base'] !== null && typeof context['@base'] === 'string'\n                && !Util_1.Util.isValidIri(context['@base'])) {\n                // The context base is relative to the document base\n                context['@base'] = (0, relative_to_absolute_iri_1.resolve)(context['@base'], options.parentContext && options.parentContext['@base'] || options.baseIRI);\n            }\n        }\n        return context;\n    }\n    /**\n     * Resolve relative context IRIs, or return full IRIs as-is.\n     * @param {string} contextIri A context IRI.\n     * @param {string} baseIRI A base IRI.\n     * @return {string} The normalized context IRI.\n     */\n    normalizeContextIri(contextIri, baseIRI) {\n        if (!Util_1.Util.isValidIri(contextIri)) {\n            try {\n                contextIri = (0, relative_to_absolute_iri_1.resolve)(contextIri, baseIRI);\n            }\n            catch (_a) {\n                throw new Error(`Invalid context IRI: ${contextIri}`);\n            }\n        }\n        // TODO: Temporary workaround for fixing schema.org CORS issues (https://github.com/schemaorg/schemaorg/issues/2578#issuecomment-652324465)\n        if (this.redirectSchemaOrgHttps && contextIri.startsWith('http://schema.org')) {\n            contextIri = 'https://schema.org/';\n        }\n        return contextIri;\n    }\n    /**\n     * Parse scoped contexts in the given context.\n     * @param {IJsonLdContextNormalizedRaw} context A context.\n     * @param {IParseOptions} options Parsing options.\n     * @return {IJsonLdContextNormalizedRaw} The mutated input context.\n     */\n    async parseInnerContexts(context, options) {\n        for (const key of Object.keys(context)) {\n            const value = context[key];\n            if (value && typeof value === 'object') {\n                if ('@context' in value && value['@context'] !== null && !options.ignoreScopedContexts) {\n                    // Simulate a processing based on the parent context to check if there are any (potential errors).\n                    // Honestly, I find it a bit weird to do this here, as the context may be unused,\n                    // and the final effective context may differ based on any other embedded/scoped contexts.\n                    // But hey, it's part of the spec, so we have no choice...\n                    // https://w3c.github.io/json-ld-api/#h-note-10\n                    if (this.validateContext) {\n                        try {\n                            const parentContext = Object.assign({}, context);\n                            parentContext[key] = Object.assign({}, parentContext[key]);\n                            delete parentContext[key]['@context'];\n                            await this.parse(value['@context'], Object.assign(Object.assign({}, options), { external: false, parentContext, ignoreProtection: true, ignoreRemoteScopedContexts: true, ignoreScopedContexts: true }));\n                        }\n                        catch (e) {\n                            throw new ErrorCoded_1.ErrorCoded(e.message, ErrorCoded_1.ERROR_CODES.INVALID_SCOPED_CONTEXT);\n                        }\n                    }\n                    value['@context'] = (await this.parse(value['@context'], Object.assign(Object.assign({}, options), { external: false, minimalProcessing: true, ignoreRemoteScopedContexts: true, parentContext: context })))\n                        .getContextRaw();\n                }\n            }\n        }\n        return context;\n    }\n    /**\n     * Parse a JSON-LD context in any form.\n     * @param {JsonLdContext} context A context, URL to a context, or an array of contexts/URLs.\n     * @param {IParseOptions} options Optional parsing options.\n     * @return {Promise<JsonLdContextNormalized>} A promise resolving to the context.\n     */\n    async parse(context, options = {}) {\n        const { baseIRI, parentContext: parentContextInitial, external, processingMode = ContextParser.DEFAULT_PROCESSING_MODE, normalizeLanguageTags, ignoreProtection, minimalProcessing, } = options;\n        let parentContext = parentContextInitial;\n        const remoteContexts = options.remoteContexts || {};\n        // Avoid remote context overflows\n        if (Object.keys(remoteContexts).length >= this.remoteContextsDepthLimit) {\n            throw new ErrorCoded_1.ErrorCoded('Detected an overflow in remote context inclusions: ' + Object.keys(remoteContexts), ErrorCoded_1.ERROR_CODES.CONTEXT_OVERFLOW);\n        }\n        if (context === null || context === undefined) {\n            // Don't allow context nullification and there are protected terms\n            if (!ignoreProtection && parentContext && Util_1.Util.hasProtectedTerms(parentContext)) {\n                throw new ErrorCoded_1.ErrorCoded('Illegal context nullification when terms are protected', ErrorCoded_1.ERROR_CODES.INVALID_CONTEXT_NULLIFICATION);\n            }\n            // Context that are explicitly set to null are empty.\n            return new JsonLdContextNormalized_1.JsonLdContextNormalized(this.applyBaseEntry({}, options, false));\n        }\n        else if (typeof context === 'string') {\n            const contextIri = this.normalizeContextIri(context, baseIRI);\n            const overriddenLoad = this.getOverriddenLoad(contextIri, options);\n            if (overriddenLoad) {\n                return new JsonLdContextNormalized_1.JsonLdContextNormalized(overriddenLoad);\n            }\n            const parsedStringContext = await this.parse(await this.load(contextIri), Object.assign(Object.assign({}, options), { baseIRI: contextIri, external: true, remoteContexts: Object.assign(Object.assign({}, remoteContexts), { [contextIri]: true }) }));\n            this.applyBaseEntry(parsedStringContext.getContextRaw(), options, true);\n            return parsedStringContext;\n        }\n        else if (Array.isArray(context)) {\n            // As a performance consideration, first load all external contexts in parallel.\n            const contextIris = [];\n            const contexts = await Promise.all(context.map((subContext, i) => {\n                if (typeof subContext === 'string') {\n                    const contextIri = this.normalizeContextIri(subContext, baseIRI);\n                    contextIris[i] = contextIri;\n                    const overriddenLoad = this.getOverriddenLoad(contextIri, options);\n                    if (overriddenLoad) {\n                        return overriddenLoad;\n                    }\n                    return this.load(contextIri);\n                }\n                else {\n                    return subContext;\n                }\n            }));\n            // Don't apply inheritance logic on minimal processing\n            if (minimalProcessing) {\n                return new JsonLdContextNormalized_1.JsonLdContextNormalized(contexts);\n            }\n            const reducedContexts = await contexts.reduce((accContextPromise, contextEntry, i) => accContextPromise\n                .then((accContext) => this.parse(contextEntry, Object.assign(Object.assign({}, options), { baseIRI: contextIris[i] || options.baseIRI, external: !!contextIris[i] || options.external, parentContext: accContext.getContextRaw(), remoteContexts: contextIris[i] ? Object.assign(Object.assign({}, remoteContexts), { [contextIris[i]]: true }) : remoteContexts }))), Promise.resolve(new JsonLdContextNormalized_1.JsonLdContextNormalized(parentContext || {})));\n            // Override the base IRI if provided.\n            this.applyBaseEntry(reducedContexts.getContextRaw(), options, true);\n            return reducedContexts;\n        }\n        else if (typeof context === 'object') {\n            if ('@context' in context) {\n                return await this.parse(context['@context'], options);\n            }\n            // Make a deep clone of the given context, to avoid modifying it.\n            context = JSON.parse(JSON.stringify(context)); // No better way in JS at the moment.\n            if (parentContext && !minimalProcessing) {\n                parentContext = JSON.parse(JSON.stringify(parentContext));\n            }\n            // We have an actual context object.\n            let newContext = {};\n            // According to the JSON-LD spec, @base must be ignored from external contexts.\n            if (external) {\n                delete context['@base'];\n            }\n            // Override the base IRI if provided.\n            this.applyBaseEntry(context, options, true);\n            // Hashify container entries\n            // Do this before protected term validation as that influences term format\n            this.containersToHash(context);\n            // Don't perform any other modifications if only minimal processing is needed.\n            if (minimalProcessing) {\n                return new JsonLdContextNormalized_1.JsonLdContextNormalized(context);\n            }\n            // In JSON-LD 1.1, load @import'ed context prior to processing.\n            let importContext = {};\n            if ('@import' in context) {\n                if (processingMode >= 1.1) {\n                    // Only accept string values\n                    if (typeof context['@import'] !== 'string') {\n                        throw new ErrorCoded_1.ErrorCoded('An @import value must be a string, but got ' + typeof context['@import'], ErrorCoded_1.ERROR_CODES.INVALID_IMPORT_VALUE);\n                    }\n                    // Load context\n                    importContext = await this.loadImportContext(this.normalizeContextIri(context['@import'], baseIRI));\n                    delete context['@import'];\n                }\n                else {\n                    throw new ErrorCoded_1.ErrorCoded('Context importing is not supported in JSON-LD 1.0', ErrorCoded_1.ERROR_CODES.INVALID_CONTEXT_ENTRY);\n                }\n            }\n            // Merge different parts of the final context in order\n            newContext = Object.assign(Object.assign(Object.assign(Object.assign({}, newContext), (typeof parentContext === 'object' ? parentContext : {})), importContext), context);\n            const newContextWrapped = new JsonLdContextNormalized_1.JsonLdContextNormalized(newContext);\n            // Parse inner contexts with minimal processing\n            await this.parseInnerContexts(newContext, options);\n            // In JSON-LD 1.1, @vocab can be relative to @vocab in the parent context.\n            if ((newContext && newContext['@version'] || ContextParser.DEFAULT_PROCESSING_MODE) >= 1.1\n                && ((context['@vocab'] && typeof context['@vocab'] === 'string') || context['@vocab'] === '')\n                && context['@vocab'].indexOf(':') < 0 && parentContext && '@vocab' in parentContext) {\n                newContext['@vocab'] = parentContext['@vocab'] + context['@vocab'];\n            }\n            // Handle terms (before protection checks)\n            this.idifyReverseTerms(newContext);\n            this.expandPrefixedTerms(newContextWrapped, this.expandContentTypeToBase);\n            // In JSON-LD 1.1, check if we are not redefining any protected keywords\n            if (!ignoreProtection && parentContext && processingMode >= 1.1) {\n                this.validateKeywordRedefinitions(parentContext, newContext, exports.defaultExpandOptions);\n            }\n            this.normalize(newContext, { processingMode, normalizeLanguageTags });\n            this.applyScopedProtected(newContext, { processingMode });\n            if (this.validateContext) {\n                this.validate(newContext, { processingMode });\n            }\n            return newContextWrapped;\n        }\n        else {\n            throw new ErrorCoded_1.ErrorCoded(`Tried parsing a context that is not a string, array or object, but got ${context}`, ErrorCoded_1.ERROR_CODES.INVALID_LOCAL_CONTEXT);\n        }\n    }\n    /**\n     * Fetch the given URL as a raw JSON-LD context.\n     * @param url An URL.\n     * @return A promise resolving to a raw JSON-LD context.\n     */\n    async load(url) {\n        // First try to retrieve the context from cache\n        const cached = this.documentCache[url];\n        if (cached) {\n            return typeof cached === 'string' ? cached : Array.isArray(cached) ? cached.slice() : Object.assign({}, cached);\n        }\n        // If not in cache, load it\n        let document;\n        try {\n            document = await this.documentLoader.load(url);\n        }\n        catch (e) {\n            throw new ErrorCoded_1.ErrorCoded(`Failed to load remote context ${url}: ${e.message}`, ErrorCoded_1.ERROR_CODES.LOADING_REMOTE_CONTEXT_FAILED);\n        }\n        // Validate the context\n        if (!('@context' in document)) {\n            throw new ErrorCoded_1.ErrorCoded(`Missing @context in remote context at ${url}`, ErrorCoded_1.ERROR_CODES.INVALID_REMOTE_CONTEXT);\n        }\n        return this.documentCache[url] = document['@context'];\n    }\n    /**\n     * Override the given context that may be loaded.\n     *\n     * This will check whether or not the url is recursively being loaded.\n     * @param url An URL.\n     * @param options Parsing options.\n     * @return An overridden context, or null.\n     *         Optionally an error can be thrown if a cyclic context is detected.\n     */\n    getOverriddenLoad(url, options) {\n        if (url in (options.remoteContexts || {})) {\n            if (options.ignoreRemoteScopedContexts) {\n                return url;\n            }\n            else {\n                throw new ErrorCoded_1.ErrorCoded('Detected a cyclic context inclusion of ' + url, ErrorCoded_1.ERROR_CODES.RECURSIVE_CONTEXT_INCLUSION);\n            }\n        }\n        return null;\n    }\n    /**\n     * Load an @import'ed context.\n     * @param importContextIri The full URI of an @import value.\n     */\n    async loadImportContext(importContextIri) {\n        // Load the context\n        const importContext = await this.load(importContextIri);\n        // Require the context to be a non-array object\n        if (typeof importContext !== 'object' || Array.isArray(importContext)) {\n            throw new ErrorCoded_1.ErrorCoded('An imported context must be a single object: ' + importContextIri, ErrorCoded_1.ERROR_CODES.INVALID_REMOTE_CONTEXT);\n        }\n        // Error if the context contains another @import\n        if ('@import' in importContext) {\n            throw new ErrorCoded_1.ErrorCoded('An imported context can not import another context: ' + importContextIri, ErrorCoded_1.ERROR_CODES.INVALID_CONTEXT_ENTRY);\n        }\n        // Containers have to be converted into hash values the same way as for the importing context\n        // Otherwise context validation will fail for container values\n        this.containersToHash(importContext);\n        return importContext;\n    }\n}\nexports.ContextParser = ContextParser;\nContextParser.DEFAULT_PROCESSING_MODE = 1.1;\nexports.defaultExpandOptions = {\n    allowPrefixForcing: true,\n    allowPrefixNonGenDelims: false,\n    allowVocabRelativeToBase: true,\n};\n//# sourceMappingURL=ContextParser.js.map","\"use strict\";\nfunction __export(m) {\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__export(require(\"./lib/Resolve\"));\n//# sourceMappingURL=index.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * Convert the given relative IRI to an absolute IRI\n * by taking into account the given optional baseIRI.\n *\n * @param {string} relativeIRI The relative IRI to convert to an absolute IRI.\n * @param {string} baseIRI The optional base IRI.\n * @return {string} an absolute IRI.\n */\nfunction resolve(relativeIRI, baseIRI) {\n    baseIRI = baseIRI || '';\n    const baseFragmentPos = baseIRI.indexOf('#');\n    // Ignore any fragments in the base IRI\n    if (baseFragmentPos > 0) {\n        baseIRI = baseIRI.substr(0, baseFragmentPos);\n    }\n    // Convert empty value directly to base IRI\n    if (!relativeIRI.length) {\n        // At this point, the baseIRI MUST be absolute, otherwise we error\n        if (baseIRI.indexOf(':') < 0) {\n            throw new Error(`Found invalid baseIRI '${baseIRI}' for value '${relativeIRI}'`);\n        }\n        return baseIRI;\n    }\n    // If the value starts with a query character, concat directly (but strip the existing query)\n    if (relativeIRI.startsWith('?')) {\n        const baseQueryPos = baseIRI.indexOf('?');\n        if (baseQueryPos > 0) {\n            baseIRI = baseIRI.substr(0, baseQueryPos);\n        }\n        return baseIRI + relativeIRI;\n    }\n    // If the value starts with a fragment character, concat directly\n    if (relativeIRI.startsWith('#')) {\n        return baseIRI + relativeIRI;\n    }\n    // Ignore baseIRI if it is empty\n    if (!baseIRI.length) {\n        const relativeColonPos = relativeIRI.indexOf(':');\n        if (relativeColonPos < 0) {\n            throw new Error(`Found invalid relative IRI '${relativeIRI}' for a missing baseIRI`);\n        }\n        return removeDotSegmentsOfPath(relativeIRI, relativeColonPos);\n    }\n    // Ignore baseIRI if the value is absolute\n    const valueColonPos = relativeIRI.indexOf(':');\n    if (valueColonPos >= 0) {\n        return removeDotSegmentsOfPath(relativeIRI, valueColonPos);\n    }\n    // At this point, the baseIRI MUST be absolute, otherwise we error\n    const baseColonPos = baseIRI.indexOf(':');\n    if (baseColonPos < 0) {\n        throw new Error(`Found invalid baseIRI '${baseIRI}' for value '${relativeIRI}'`);\n    }\n    const baseIRIScheme = baseIRI.substr(0, baseColonPos + 1);\n    // Inherit the baseIRI scheme if the value starts with '//'\n    if (relativeIRI.indexOf('//') === 0) {\n        return baseIRIScheme + removeDotSegmentsOfPath(relativeIRI, valueColonPos);\n    }\n    // Check cases where '://' occurs in the baseIRI, and where there is no '/' after a ':' anymore.\n    let baseSlashAfterColonPos;\n    if (baseIRI.indexOf('//', baseColonPos) === baseColonPos + 1) {\n        // If there is no additional '/' after the '//'.\n        baseSlashAfterColonPos = baseIRI.indexOf('/', baseColonPos + 3);\n        if (baseSlashAfterColonPos < 0) {\n            // If something other than a '/' follows the '://', append the value after a '/',\n            // otherwise, prefix the value with only the baseIRI scheme.\n            if (baseIRI.length > baseColonPos + 3) {\n                return baseIRI + '/' + removeDotSegmentsOfPath(relativeIRI, valueColonPos);\n            }\n            else {\n                return baseIRIScheme + removeDotSegmentsOfPath(relativeIRI, valueColonPos);\n            }\n        }\n    }\n    else {\n        // If there is not even a single '/' after the ':'\n        baseSlashAfterColonPos = baseIRI.indexOf('/', baseColonPos + 1);\n        if (baseSlashAfterColonPos < 0) {\n            // If we don't have a '/' after the ':',\n            // prefix the value with only the baseIRI scheme.\n            return baseIRIScheme + removeDotSegmentsOfPath(relativeIRI, valueColonPos);\n        }\n    }\n    // If the value starts with a '/', then prefix it with everything before the first effective slash of the base IRI.\n    if (relativeIRI.indexOf('/') === 0) {\n        return baseIRI.substr(0, baseSlashAfterColonPos) + removeDotSegments(relativeIRI);\n    }\n    let baseIRIPath = baseIRI.substr(baseSlashAfterColonPos);\n    const baseIRILastSlashPos = baseIRIPath.lastIndexOf('/');\n    // Ignore everything after the last '/' in the baseIRI path\n    if (baseIRILastSlashPos >= 0 && baseIRILastSlashPos < baseIRIPath.length - 1) {\n        baseIRIPath = baseIRIPath.substr(0, baseIRILastSlashPos + 1);\n        // Also remove the first character of the relative path if it starts with '.' (and not '..' or './')\n        // This change is only allowed if there is something else following the path\n        if (relativeIRI[0] === '.' && relativeIRI[1] !== '.' && relativeIRI[1] !== '/' && relativeIRI[2]) {\n            relativeIRI = relativeIRI.substr(1);\n        }\n    }\n    // Prefix the value with the baseIRI path where\n    relativeIRI = baseIRIPath + relativeIRI;\n    // Remove dot segment from the IRI\n    relativeIRI = removeDotSegments(relativeIRI);\n    // Prefix our transformed value with the part of the baseIRI until the first '/' after the first ':'.\n    return baseIRI.substr(0, baseSlashAfterColonPos) + relativeIRI;\n}\nexports.resolve = resolve;\n/**\n * Remove dot segments from the given path,\n * as described in https://www.ietf.org/rfc/rfc3986.txt (page 32).\n * @param {string} path An IRI path.\n * @return {string} A path, will always start with a '/'.\n */\nfunction removeDotSegments(path) {\n    // Prepare a buffer with segments between each '/.\n    // Each segment represents an array of characters.\n    const segmentBuffers = [];\n    let i = 0;\n    while (i < path.length) {\n        // Remove '/.' or '/..'\n        switch (path[i]) {\n            case '/':\n                if (path[i + 1] === '.') {\n                    if (path[i + 2] === '.') {\n                        // Start a new segment if we find an invalid character after the '.'\n                        if (!isCharacterAllowedAfterRelativePathSegment(path[i + 3])) {\n                            segmentBuffers.push([]);\n                            i++;\n                            break;\n                        }\n                        // Go to parent directory,\n                        // so we remove a parent segment\n                        segmentBuffers.pop();\n                        // Ensure that we end with a slash if there is a trailing '/..'\n                        if (!path[i + 3]) {\n                            segmentBuffers.push([]);\n                        }\n                        i += 3;\n                    }\n                    else {\n                        // Start a new segment if we find an invalid character after the '.'\n                        if (!isCharacterAllowedAfterRelativePathSegment(path[i + 2])) {\n                            segmentBuffers.push([]);\n                            i++;\n                            break;\n                        }\n                        // Ensure that we end with a slash if there is a trailing '/.'\n                        if (!path[i + 2]) {\n                            segmentBuffers.push([]);\n                        }\n                        // Go to the current directory,\n                        // so we do nothing\n                        i += 2;\n                    }\n                }\n                else {\n                    // Start a new segment\n                    segmentBuffers.push([]);\n                    i++;\n                }\n                break;\n            case '#':\n            case '?':\n                // Query and fragment string should be appended unchanged\n                if (!segmentBuffers.length) {\n                    segmentBuffers.push([]);\n                }\n                segmentBuffers[segmentBuffers.length - 1].push(path.substr(i));\n                // Break the while loop\n                i = path.length;\n                break;\n            default:\n                // Not a special character, just append it to our buffer\n                if (!segmentBuffers.length) {\n                    segmentBuffers.push([]);\n                }\n                segmentBuffers[segmentBuffers.length - 1].push(path[i]);\n                i++;\n                break;\n        }\n    }\n    return '/' + segmentBuffers.map((buffer) => buffer.join('')).join('/');\n}\nexports.removeDotSegments = removeDotSegments;\n/**\n * Removes dot segments of the given IRI.\n * @param {string} iri An IRI (or part of IRI).\n * @param {number} colonPosition The position of the first ':' in the IRI.\n * @return {string} The IRI where dot segments were removed.\n */\nfunction removeDotSegmentsOfPath(iri, colonPosition) {\n    // Determine where we should start looking for the first '/' that indicates the start of the path\n    let searchOffset = colonPosition + 1;\n    if (colonPosition >= 0) {\n        if (iri[colonPosition + 1] === '/' && iri[colonPosition + 2] === '/') {\n            searchOffset = colonPosition + 3;\n        }\n    }\n    else {\n        if (iri[0] === '/' && iri[1] === '/') {\n            searchOffset = 2;\n        }\n    }\n    // Determine the path\n    const pathSeparator = iri.indexOf('/', searchOffset);\n    if (pathSeparator < 0) {\n        return iri;\n    }\n    const base = iri.substr(0, pathSeparator);\n    const path = iri.substr(pathSeparator);\n    // Remove dot segments from the path\n    return base + removeDotSegments(path);\n}\nexports.removeDotSegmentsOfPath = removeDotSegmentsOfPath;\nfunction isCharacterAllowedAfterRelativePathSegment(character) {\n    return !character || character === '#' || character === '?' || character === '/';\n}\n//# sourceMappingURL=Resolve.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ERROR_CODES = exports.ErrorCoded = void 0;\n/**\n * An error that has a certain error code.\n *\n * The error code can be any string.\n * All standardized error codes are listed in {@link ERROR_CODES}.\n */\nclass ErrorCoded extends Error {\n    /* istanbul ignore next */\n    constructor(message, code) {\n        super(message);\n        this.code = code;\n    }\n}\nexports.ErrorCoded = ErrorCoded;\n/**\n * All standardized JSON-LD error codes.\n * @see https://w3c.github.io/json-ld-api/#dom-jsonlderrorcode\n */\n// tslint:disable:object-literal-sort-keys\nvar ERROR_CODES;\n(function (ERROR_CODES) {\n    ERROR_CODES[\"COLLIDING_KEYWORDS\"] = \"colliding keywords\";\n    ERROR_CODES[\"CONFLICTING_INDEXES\"] = \"conflicting indexes\";\n    ERROR_CODES[\"CYCLIC_IRI_MAPPING\"] = \"cyclic IRI mapping\";\n    ERROR_CODES[\"INVALID_ID_VALUE\"] = \"invalid @id value\";\n    ERROR_CODES[\"INVALID_INDEX_VALUE\"] = \"invalid @index value\";\n    ERROR_CODES[\"INVALID_NEST_VALUE\"] = \"invalid @nest value\";\n    ERROR_CODES[\"INVALID_PREFIX_VALUE\"] = \"invalid @prefix value\";\n    ERROR_CODES[\"INVALID_PROPAGATE_VALUE\"] = \"invalid @propagate value\";\n    ERROR_CODES[\"INVALID_REVERSE_VALUE\"] = \"invalid @reverse value\";\n    ERROR_CODES[\"INVALID_IMPORT_VALUE\"] = \"invalid @import value\";\n    ERROR_CODES[\"INVALID_VERSION_VALUE\"] = \"invalid @version value\";\n    ERROR_CODES[\"INVALID_BASE_IRI\"] = \"invalid base IRI\";\n    ERROR_CODES[\"INVALID_CONTAINER_MAPPING\"] = \"invalid container mapping\";\n    ERROR_CODES[\"INVALID_CONTEXT_ENTRY\"] = \"invalid context entry\";\n    ERROR_CODES[\"INVALID_CONTEXT_NULLIFICATION\"] = \"invalid context nullification\";\n    ERROR_CODES[\"INVALID_DEFAULT_LANGUAGE\"] = \"invalid default language\";\n    ERROR_CODES[\"INVALID_INCLUDED_VALUE\"] = \"invalid @included value\";\n    ERROR_CODES[\"INVALID_IRI_MAPPING\"] = \"invalid IRI mapping\";\n    ERROR_CODES[\"INVALID_JSON_LITERAL\"] = \"invalid JSON literal\";\n    ERROR_CODES[\"INVALID_KEYWORD_ALIAS\"] = \"invalid keyword alias\";\n    ERROR_CODES[\"INVALID_LANGUAGE_MAP_VALUE\"] = \"invalid language map value\";\n    ERROR_CODES[\"INVALID_LANGUAGE_MAPPING\"] = \"invalid language mapping\";\n    ERROR_CODES[\"INVALID_LANGUAGE_TAGGED_STRING\"] = \"invalid language-tagged string\";\n    ERROR_CODES[\"INVALID_LANGUAGE_TAGGED_VALUE\"] = \"invalid language-tagged value\";\n    ERROR_CODES[\"INVALID_LOCAL_CONTEXT\"] = \"invalid local context\";\n    ERROR_CODES[\"INVALID_REMOTE_CONTEXT\"] = \"invalid remote context\";\n    ERROR_CODES[\"INVALID_REVERSE_PROPERTY\"] = \"invalid reverse property\";\n    ERROR_CODES[\"INVALID_REVERSE_PROPERTY_MAP\"] = \"invalid reverse property map\";\n    ERROR_CODES[\"INVALID_REVERSE_PROPERTY_VALUE\"] = \"invalid reverse property value\";\n    ERROR_CODES[\"INVALID_SCOPED_CONTEXT\"] = \"invalid scoped context\";\n    ERROR_CODES[\"INVALID_SCRIPT_ELEMENT\"] = \"invalid script element\";\n    ERROR_CODES[\"INVALID_SET_OR_LIST_OBJECT\"] = \"invalid set or list object\";\n    ERROR_CODES[\"INVALID_TERM_DEFINITION\"] = \"invalid term definition\";\n    ERROR_CODES[\"INVALID_TYPE_MAPPING\"] = \"invalid type mapping\";\n    ERROR_CODES[\"INVALID_TYPE_VALUE\"] = \"invalid type value\";\n    ERROR_CODES[\"INVALID_TYPED_VALUE\"] = \"invalid typed value\";\n    ERROR_CODES[\"INVALID_VALUE_OBJECT\"] = \"invalid value object\";\n    ERROR_CODES[\"INVALID_VALUE_OBJECT_VALUE\"] = \"invalid value object value\";\n    ERROR_CODES[\"INVALID_VOCAB_MAPPING\"] = \"invalid vocab mapping\";\n    ERROR_CODES[\"IRI_CONFUSED_WITH_PREFIX\"] = \"IRI confused with prefix\";\n    ERROR_CODES[\"KEYWORD_REDEFINITION\"] = \"keyword redefinition\";\n    ERROR_CODES[\"LOADING_DOCUMENT_FAILED\"] = \"loading document failed\";\n    ERROR_CODES[\"LOADING_REMOTE_CONTEXT_FAILED\"] = \"loading remote context failed\";\n    ERROR_CODES[\"MULTIPLE_CONTEXT_LINK_HEADERS\"] = \"multiple context link headers\";\n    ERROR_CODES[\"PROCESSING_MODE_CONFLICT\"] = \"processing mode conflict\";\n    ERROR_CODES[\"PROTECTED_TERM_REDEFINITION\"] = \"protected term redefinition\";\n    ERROR_CODES[\"CONTEXT_OVERFLOW\"] = \"context overflow\";\n    ERROR_CODES[\"INVALID_BASE_DIRECTION\"] = \"invalid base direction\";\n    ERROR_CODES[\"RECURSIVE_CONTEXT_INCLUSION\"] = \"recursive context inclusion\";\n    ERROR_CODES[\"INVALID_STREAMING_KEY_ORDER\"] = \"invalid streaming key order\";\n})(ERROR_CODES = exports.ERROR_CODES || (exports.ERROR_CODES = {}));\n//# sourceMappingURL=ErrorCoded.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.FetchDocumentLoader = void 0;\nrequire(\"cross-fetch/polyfill\");\nconst ErrorCoded_1 = require(\"./ErrorCoded\");\nconst http_link_header_1 = require(\"http-link-header\");\nconst relative_to_absolute_iri_1 = require(\"relative-to-absolute-iri\");\n/**\n * Loads documents via the fetch API.\n */\nclass FetchDocumentLoader {\n    constructor(fetcher) {\n        this.fetcher = fetcher;\n    }\n    async load(url) {\n        const response = await (this.fetcher || fetch)(url, { headers: new Headers({ accept: 'application/ld+json' }) });\n        if (response.ok && response.headers) {\n            let mediaType = response.headers.get('Content-Type');\n            if (mediaType) {\n                const colonPos = mediaType.indexOf(';');\n                if (colonPos > 0) {\n                    mediaType = mediaType.substr(0, colonPos);\n                }\n            }\n            if (mediaType === 'application/ld+json') {\n                // Return JSON-LD if proper content type was returned\n                return (await response.json());\n            }\n            else {\n                // Check for alternate link for a non-JSON-LD response\n                if (response.headers.has('Link')) {\n                    let alternateUrl;\n                    response.headers.forEach((value, key) => {\n                        if (key === 'link') {\n                            const linkHeader = (0, http_link_header_1.parse)(value);\n                            for (const link of linkHeader.get('type', 'application/ld+json')) {\n                                if (link.rel === 'alternate') {\n                                    if (alternateUrl) {\n                                        throw new Error('Multiple JSON-LD alternate links were found on ' + url);\n                                    }\n                                    alternateUrl = (0, relative_to_absolute_iri_1.resolve)(link.uri, url);\n                                }\n                            }\n                        }\n                    });\n                    if (alternateUrl) {\n                        return this.load(alternateUrl);\n                    }\n                }\n                throw new ErrorCoded_1.ErrorCoded(`Unsupported JSON-LD media type ${mediaType}`, ErrorCoded_1.ERROR_CODES.LOADING_DOCUMENT_FAILED);\n            }\n        }\n        else {\n            throw new Error(response.statusText || `Status code: ${response.status}`);\n        }\n    }\n}\nexports.FetchDocumentLoader = FetchDocumentLoader;\n//# sourceMappingURL=FetchDocumentLoader.js.map","'use strict'\n\nvar COMPATIBLE_ENCODING_PATTERN = /^utf-?8|ascii|utf-?16-?le|ucs-?2|base-?64|latin-?1$/i\nvar WS_TRIM_PATTERN = /^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$/g\nvar WS_CHAR_PATTERN = /\\s|\\uFEFF|\\xA0/\nvar WS_FOLD_PATTERN = /\\r?\\n[\\x20\\x09]+/g\nvar DELIMITER_PATTERN = /[;,\"]/\nvar WS_DELIMITER_PATTERN = /[;,\"]|\\s/\n\n/**\n * Token character pattern\n * @type {RegExp}\n * @see https://tools.ietf.org/html/rfc7230#section-3.2.6\n */\nvar TOKEN_PATTERN = /^[!#$%&'*+\\-\\.^_`|~\\da-zA-Z]+$/\n\nvar STATE = {\n  IDLE: 1 << 0,\n  URI: 1 << 1,\n  ATTR: 1 << 2,\n}\n\nfunction trim( value ) {\n  return value.replace( WS_TRIM_PATTERN, '' )\n}\n\nfunction hasWhitespace( value ) {\n  return WS_CHAR_PATTERN.test( value )\n}\n\nfunction skipWhitespace( value, offset ) {\n  while( hasWhitespace( value[offset] ) ) {\n    offset++\n  }\n  return offset\n}\n\nfunction needsQuotes( value ) {\n  return WS_DELIMITER_PATTERN.test( value ) ||\n    !TOKEN_PATTERN.test( value )\n}\n\nclass Link {\n\n  /**\n   * Link\n   * @constructor\n   * @param {String} [value]\n   * @returns {Link}\n   */\n  constructor( value ) {\n\n    /** @type {Array} URI references */\n    this.refs = []\n\n    if( value ) {\n      this.parse( value )\n    }\n\n  }\n\n  /**\n   * Get refs with given relation type\n   * @param {String} value\n   * @returns {Array<Object>}\n   */\n  rel( value ) {\n\n    var links = []\n    var type = value.toLowerCase()\n\n    for( var i = 0; i < this.refs.length; i++ ) {\n      if( this.refs[ i ].rel.toLowerCase() === type ) {\n        links.push( this.refs[ i ] )\n      }\n    }\n\n    return links\n\n  }\n\n  /**\n   * Get refs where given attribute has a given value\n   * @param {String} attr\n   * @param {String} value\n   * @returns {Array<Object>}\n   */\n  get( attr, value ) {\n\n    attr = attr.toLowerCase()\n\n    var links = []\n\n    for( var i = 0; i < this.refs.length; i++ ) {\n      if( this.refs[ i ][ attr ] === value ) {\n        links.push( this.refs[ i ] )\n      }\n    }\n\n    return links\n\n  }\n\n  set( link ) {\n    this.refs.push( link )\n    return this\n  }\n\n  has( attr, value ) {\n\n    attr = attr.toLowerCase()\n\n    for( var i = 0; i < this.refs.length; i++ ) {\n      if( this.refs[ i ][ attr ] === value ) {\n        return true\n      }\n    }\n\n    return false\n\n  }\n\n  parse( value, offset ) {\n\n    offset = offset || 0\n    value = offset ? value.slice( offset ) : value\n\n    // Trim & unfold folded lines\n    value = trim( value ).replace( WS_FOLD_PATTERN, '' )\n\n    var state = STATE.IDLE\n    var length = value.length\n    var offset = 0\n    var ref = null\n\n    while( offset < length ) {\n      if( state === STATE.IDLE ) {\n        if( hasWhitespace( value[offset] ) ) {\n          offset++\n          continue\n        } else if( value[offset] === '<' ) {\n          if( ref != null ) {\n            ref.rel != null ?\n              this.refs.push( ...Link.expandRelations( ref ) ) :\n              this.refs.push( ref )\n          }\n          var end = value.indexOf( '>', offset )\n          if( end === -1 ) throw new Error( 'Expected end of URI delimiter at offset ' + offset )\n          ref = { uri: value.slice( offset + 1, end ) }\n          // this.refs.push( ref )\n          offset = end\n          state = STATE.URI\n        } else {\n          throw new Error( 'Unexpected character \"' + value[offset] + '\" at offset ' + offset )\n        }\n        offset++\n      } else if( state === STATE.URI ) {\n        if( hasWhitespace( value[offset] ) ) {\n          offset++\n          continue\n        } else if( value[offset] === ';' ) {\n          state = STATE.ATTR\n          offset++\n        } else if( value[offset] === ',' ) {\n          state = STATE.IDLE\n          offset++\n        } else {\n          throw new Error( 'Unexpected character \"' + value[offset] + '\" at offset ' + offset )\n        }\n      } else if( state === STATE.ATTR ) {\n        if( value[offset] ===';' || hasWhitespace( value[offset] ) ) {\n          offset++\n          continue\n        }\n        var end = value.indexOf( '=', offset )\n        if( end === -1 ) throw new Error( 'Expected attribute delimiter at offset ' + offset )\n        var attr = trim( value.slice( offset, end ) ).toLowerCase()\n        var attrValue = ''\n        offset = end + 1\n        offset = skipWhitespace( value, offset )\n        if( value[offset] === '\"' ) {\n          offset++\n          while( offset < length ) {\n            if( value[offset] === '\"' ) {\n              offset++; break\n            }\n            if( value[offset] === '\\\\' ) {\n              offset++\n            }\n            attrValue += value[offset]\n            offset++\n          }\n        } else {\n          var end = offset + 1\n          while( !DELIMITER_PATTERN.test( value[end] ) && end < length ) {\n            end++\n          }\n          attrValue = value.slice( offset, end )\n          offset = end\n        }\n        if( ref[ attr ] && Link.isSingleOccurenceAttr( attr ) ) {\n          // Ignore multiples of attributes which may only appear once\n        } else if( attr[ attr.length - 1 ] === '*' ) {\n          ref[ attr ] = Link.parseExtendedValue( attrValue )\n        } else {\n          attrValue = attr === 'type' ?\n            attrValue.toLowerCase() : attrValue\n          if( ref[ attr ] != null ) {\n            if( Array.isArray( ref[ attr ] ) ) {\n              ref[ attr ].push( attrValue )\n            } else {\n              ref[ attr ] = [ ref[ attr ], attrValue ]\n            }\n          } else {\n            ref[ attr ] = attrValue\n          }\n        }\n        switch( value[offset] ) {\n          case ',': state = STATE.IDLE; break\n          case ';': state = STATE.ATTR; break\n        }\n        offset++\n      } else {\n        throw new Error( 'Unknown parser state \"' + state + '\"' )\n      }\n    }\n\n    if( ref != null ) {\n      ref.rel != null ?\n        this.refs.push( ...Link.expandRelations( ref ) ) :\n        this.refs.push( ref )\n    }\n\n    ref = null\n\n    return this\n\n  }\n\n  toString() {\n\n    var refs = []\n    var link = ''\n    var ref = null\n\n    for( var i = 0; i < this.refs.length; i++ ) {\n      ref = this.refs[i]\n      link = Object.keys( this.refs[i] ).reduce( function( link, attr ) {\n        if( attr === 'uri' ) return link\n        return link + '; ' + Link.formatAttribute( attr, ref[ attr ] )\n      }, '<' + ref.uri + '>' )\n      refs.push( link )\n    }\n\n    return refs.join( ', ' )\n\n  }\n\n}\n\n/**\n * Determines whether an encoding can be\n * natively handled with a `Buffer`\n * @param {String} value\n * @returns {Boolean}\n */\nLink.isCompatibleEncoding = function( value ) {\n  return COMPATIBLE_ENCODING_PATTERN.test( value )\n}\n\nLink.parse = function( value, offset ) {\n  return new Link().parse( value, offset )\n}\n\nLink.isSingleOccurenceAttr = function( attr ) {\n  return attr === 'rel' || attr === 'type' || attr === 'media' ||\n    attr === 'title' || attr === 'title*'\n}\n\nLink.isTokenAttr = function( attr ) {\n  return attr === 'rel' || attr === 'type' || attr === 'anchor'\n}\n\nLink.escapeQuotes = function( value ) {\n  return value.replace( /\"/g, '\\\\\"' )\n}\n\nLink.expandRelations = function( ref ) {\n  var rels = ref.rel.split( ' ' )\n  return rels.map( function( rel ) {\n    var value = Object.assign( {}, ref )\n    value.rel = rel\n    return value\n  })\n}\n\n/**\n * Parses an extended value and attempts to decode it\n * @internal\n * @param {String} value\n * @return {Object}\n */\nLink.parseExtendedValue = function( value ) {\n  var parts = /([^']+)?(?:'([^']*)')?(.+)/.exec( value )\n  return {\n    language: parts[2].toLowerCase(),\n    encoding: Link.isCompatibleEncoding( parts[1] ) ?\n      null : parts[1].toLowerCase(),\n    value: Link.isCompatibleEncoding( parts[1] ) ?\n      decodeURIComponent( parts[3] ) : parts[3]\n  }\n}\n\n/**\n * Format a given extended attribute and it's value\n * @param {String} attr\n * @param {Object} data\n * @return {String}\n */\nLink.formatExtendedAttribute = function( attr, data ) {\n\n  var encoding = ( data.encoding || 'utf-8' ).toUpperCase()\n  var language = data.language || 'en'\n\n  var encodedValue = ''\n\n  if( Buffer.isBuffer( data.value ) && Link.isCompatibleEncoding( encoding ) ) {\n    encodedValue = data.value.toString( encoding )\n  } else if( Buffer.isBuffer( data.value ) ) {\n    encodedValue = data.value.toString( 'hex' )\n      .replace( /[0-9a-f]{2}/gi, '%$1' )\n  } else {\n    encodedValue = encodeURIComponent( data.value )\n  }\n\n  return attr + '=' + encoding + '\\'' +\n    language + '\\'' + encodedValue\n\n}\n\n/**\n * Format a given attribute and it's value\n * @param {String} attr\n * @param {String|Object} value\n * @return {String}\n */\nLink.formatAttribute = function( attr, value ) {\n\n  if( Array.isArray( value ) ) {\n    return value.map(( item ) => {\n      return Link.formatAttribute( attr, item )\n    }).join( '; ' )\n  }\n\n  if( attr[ attr.length - 1 ] === '*' || typeof value !== 'string' ) {\n    return Link.formatExtendedAttribute( attr, value )\n  }\n\n  if( Link.isTokenAttr( attr ) ) {\n    value = needsQuotes( value ) ?\n      '\"' + Link.escapeQuotes( value ) + '\"' :\n      Link.escapeQuotes( value )\n  } else if( needsQuotes( value ) ) {\n    value = encodeURIComponent( value )\n    // We don't need to escape <SP> <,> <;> within quotes\n    value = value\n      .replace( /%20/g, ' ' )\n      .replace( /%2C/g, ',' )\n      .replace( /%3B/g, ';' )\n\n    value = '\"' + value + '\"'\n  }\n\n  return attr + '=' + value\n\n}\n\nmodule.exports = Link\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.JsonLdContextNormalized = void 0;\nconst relative_to_absolute_iri_1 = require(\"relative-to-absolute-iri\");\nconst ContextParser_1 = require(\"./ContextParser\");\nconst ErrorCoded_1 = require(\"./ErrorCoded\");\nconst Util_1 = require(\"./Util\");\n/**\n * A class exposing operations over a normalized JSON-LD context.\n */\nclass JsonLdContextNormalized {\n    constructor(contextRaw) {\n        this.contextRaw = contextRaw;\n    }\n    /**\n     * @return The raw inner context.\n     */\n    getContextRaw() {\n        return this.contextRaw;\n    }\n    /**\n     * Expand the term or prefix of the given term if it has one,\n     * otherwise return the term as-is.\n     *\n     * This will try to expand the IRI as much as possible.\n     *\n     * Iff in vocab-mode, then other references to other terms in the context can be used,\n     * such as to `myTerm`:\n     * ```\n     * {\n     *   \"myTerm\": \"http://example.org/myLongTerm\"\n     * }\n     * ```\n     *\n     * @param {string} term A term that is an URL or a prefixed URL.\n     * @param {boolean} expandVocab If the term is a predicate or type and should be expanded based on @vocab,\n     *                              otherwise it is considered a regular term that is expanded based on @base.\n     * @param {IExpandOptions} options Options that define the way how expansion must be done.\n     * @return {string} The expanded term, the term as-is, or null if it was explicitly disabled in the context.\n     * @throws If the term is aliased to an invalid value (not a string, IRI or keyword).\n     */\n    expandTerm(term, expandVocab, options = ContextParser_1.defaultExpandOptions) {\n        const contextValue = this.contextRaw[term];\n        // Immediately return if the term was disabled in the context\n        if (contextValue === null || (contextValue && contextValue['@id'] === null)) {\n            return null;\n        }\n        // Check the @id\n        let validIriMapping = true;\n        if (contextValue && expandVocab) {\n            const value = Util_1.Util.getContextValueId(contextValue);\n            if (value && value !== term) {\n                if (typeof value !== 'string' || (!Util_1.Util.isValidIri(value) && !Util_1.Util.isValidKeyword(value))) {\n                    // Don't mark this mapping as invalid if we have an unknown keyword, but of the correct form.\n                    if (!Util_1.Util.isPotentialKeyword(value)) {\n                        validIriMapping = false;\n                    }\n                }\n                else {\n                    return value;\n                }\n            }\n        }\n        // Check if the term is prefixed\n        const prefix = Util_1.Util.getPrefix(term, this.contextRaw);\n        const vocab = this.contextRaw['@vocab'];\n        const vocabRelative = (!!vocab || vocab === '') && vocab.indexOf(':') < 0;\n        const base = this.contextRaw['@base'];\n        const potentialKeyword = Util_1.Util.isPotentialKeyword(term);\n        if (prefix) {\n            const contextPrefixValue = this.contextRaw[prefix];\n            const value = Util_1.Util.getContextValueId(contextPrefixValue);\n            if (value) {\n                if (typeof contextPrefixValue === 'string' || !options.allowPrefixForcing) {\n                    // If we have a simple term definition,\n                    // check the last character of the prefix to determine whether or not it is a prefix.\n                    // Validate that prefix ends with gen-delim character, unless @prefix is true\n                    if (!Util_1.Util.isSimpleTermDefinitionPrefix(value, options)) {\n                        // Treat the term as an absolute IRI\n                        return term;\n                    }\n                }\n                else {\n                    // If we have an expanded term definition, default to @prefix: false\n                    if (value[0] !== '_' && !potentialKeyword && !contextPrefixValue['@prefix'] && !(term in this.contextRaw)) {\n                        // Treat the term as an absolute IRI\n                        return term;\n                    }\n                }\n                return value + term.substr(prefix.length + 1);\n            }\n        }\n        else if (expandVocab && ((vocab || vocab === '') || (options.allowVocabRelativeToBase && (base && vocabRelative)))\n            && !potentialKeyword && !Util_1.Util.isCompactIri(term)) {\n            if (vocabRelative) {\n                if (options.allowVocabRelativeToBase) {\n                    return ((vocab || base) ? (0, relative_to_absolute_iri_1.resolve)(vocab, base) : '') + term;\n                }\n                else {\n                    throw new ErrorCoded_1.ErrorCoded(`Relative vocab expansion for term '${term}' with vocab '${vocab}' is not allowed.`, ErrorCoded_1.ERROR_CODES.INVALID_VOCAB_MAPPING);\n                }\n            }\n            else {\n                return vocab + term;\n            }\n        }\n        else if (!expandVocab && base && !potentialKeyword && !Util_1.Util.isCompactIri(term)) {\n            return (0, relative_to_absolute_iri_1.resolve)(term, base);\n        }\n        // Return the term as-is, unless we discovered an invalid IRI mapping for this term in the context earlier.\n        if (validIriMapping) {\n            return term;\n        }\n        else {\n            throw new ErrorCoded_1.ErrorCoded(`Invalid IRI mapping found for context entry '${term}': '${JSON.stringify(contextValue)}'`, ErrorCoded_1.ERROR_CODES.INVALID_IRI_MAPPING);\n        }\n    }\n    /**\n     * Compact the given term using @base, @vocab, an aliased term, or a prefixed term.\n     *\n     * This will try to compact the IRI as much as possible.\n     *\n     * @param {string} iri An IRI to compact.\n     * @param {boolean} vocab If the term is a predicate or type and should be compacted based on @vocab,\n     *                        otherwise it is considered a regular term that is compacted based on @base.\n     * @return {string} The compacted term or the IRI as-is.\n     */\n    compactIri(iri, vocab) {\n        // Try @vocab compacting\n        if (vocab && this.contextRaw['@vocab'] && iri.startsWith(this.contextRaw['@vocab'])) {\n            return iri.substr(this.contextRaw['@vocab'].length);\n        }\n        // Try @base compacting\n        if (!vocab && this.contextRaw['@base'] && iri.startsWith(this.contextRaw['@base'])) {\n            return iri.substr(this.contextRaw['@base'].length);\n        }\n        // Loop over all terms in the context\n        // This will try to prefix as short as possible.\n        // Once a fully compacted alias is found, return immediately, as we can not go any shorter.\n        const shortestPrefixing = { prefix: '', suffix: iri };\n        for (const key in this.contextRaw) {\n            const value = this.contextRaw[key];\n            if (value && !Util_1.Util.isPotentialKeyword(key)) {\n                const contextIri = Util_1.Util.getContextValueId(value);\n                if (iri.startsWith(contextIri)) {\n                    const suffix = iri.substr(contextIri.length);\n                    if (!suffix) {\n                        if (vocab) {\n                            // Immediately return on compacted alias\n                            return key;\n                        }\n                    }\n                    else if (suffix.length < shortestPrefixing.suffix.length) {\n                        // Overwrite the shortest prefix\n                        shortestPrefixing.prefix = key;\n                        shortestPrefixing.suffix = suffix;\n                    }\n                }\n            }\n        }\n        // Return the shortest prefix\n        if (shortestPrefixing.prefix) {\n            return shortestPrefixing.prefix + ':' + shortestPrefixing.suffix;\n        }\n        return iri;\n    }\n}\nexports.JsonLdContextNormalized = JsonLdContextNormalized;\n//# sourceMappingURL=JsonLdContextNormalized.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Util = void 0;\nclass Util {\n    /**\n     * Check if the given term is a valid compact IRI.\n     * Otherwise, it may be an IRI.\n     * @param {string} term A term.\n     * @return {boolean} If it is a compact IRI.\n     */\n    static isCompactIri(term) {\n        return term.indexOf(':') > 0 && !(term && term[0] === '#');\n    }\n    /**\n     * Get the prefix from the given term.\n     * @see https://json-ld.org/spec/latest/json-ld/#compact-iris\n     * @param {string} term A term that is an URL or a prefixed URL.\n     * @param {IJsonLdContextNormalizedRaw} context A context.\n     * @return {string} The prefix or null.\n     */\n    static getPrefix(term, context) {\n        // Do not consider relative IRIs starting with a hash as compact IRIs\n        if (term && term[0] === '#') {\n            return null;\n        }\n        const separatorPos = term.indexOf(':');\n        if (separatorPos >= 0) {\n            // Suffix can not begin with two slashes\n            if (term.length > separatorPos + 1\n                && term.charAt(separatorPos + 1) === '/'\n                && term.charAt(separatorPos + 2) === '/') {\n                return null;\n            }\n            const prefix = term.substr(0, separatorPos);\n            // Prefix can not be an underscore (this is a blank node)\n            if (prefix === '_') {\n                return null;\n            }\n            // Prefix must match a term in the active context\n            if (context[prefix]) {\n                return prefix;\n            }\n        }\n        return null;\n    }\n    /**\n     * From a given context entry value, get the string value, or the @id field.\n     * @param contextValue A value for a term in a context.\n     * @return {string} The id value, or null.\n     */\n    static getContextValueId(contextValue) {\n        if (contextValue === null || typeof contextValue === 'string') {\n            return contextValue;\n        }\n        const id = contextValue['@id'];\n        return id ? id : null;\n    }\n    /**\n     * Check if the given simple term definition (string-based value of a context term)\n     * should be considered a prefix.\n     * @param value A simple term definition value.\n     * @param options Options that define the way how expansion must be done.\n     */\n    static isSimpleTermDefinitionPrefix(value, options) {\n        return !Util.isPotentialKeyword(value)\n            && (value[0] === '_' || options.allowPrefixNonGenDelims || Util.isPrefixIriEndingWithGenDelim(value));\n    }\n    /**\n     * Check if the given keyword is of the keyword format \"@\"1*ALPHA.\n     * @param {string} keyword A potential keyword.\n     * @return {boolean} If the given keyword is of the keyword format.\n     */\n    static isPotentialKeyword(keyword) {\n        return typeof keyword === 'string' && Util.KEYWORD_REGEX.test(keyword);\n    }\n    /**\n     * Check if the given prefix ends with a gen-delim character.\n     * @param {string} prefixIri A prefix IRI.\n     * @return {boolean} If the given prefix IRI is valid.\n     */\n    static isPrefixIriEndingWithGenDelim(prefixIri) {\n        return Util.ENDS_WITH_GEN_DELIM.test(prefixIri);\n    }\n    /**\n     * Check if the given context value can be a prefix value.\n     * @param value A context value.\n     * @return {boolean} If it can be a prefix value.\n     */\n    static isPrefixValue(value) {\n        return value && (typeof value === 'string' || (value && typeof value === 'object'));\n    }\n    /**\n     * Check if the given IRI is valid.\n     * @param {string} iri A potential IRI.\n     * @return {boolean} If the given IRI is valid.\n     */\n    static isValidIri(iri) {\n        return Boolean(iri && Util.IRI_REGEX.test(iri));\n    }\n    /**\n     * Check if the given IRI is valid, this includes the possibility of being a relative IRI.\n     * @param {string} iri A potential IRI.\n     * @return {boolean} If the given IRI is valid.\n     */\n    static isValidIriWeak(iri) {\n        return !!iri && iri[0] !== ':' && Util.IRI_REGEX_WEAK.test(iri);\n    }\n    /**\n     * Check if the given keyword is a defined according to the JSON-LD specification.\n     * @param {string} keyword A potential keyword.\n     * @return {boolean} If the given keyword is valid.\n     */\n    static isValidKeyword(keyword) {\n        return Util.VALID_KEYWORDS[keyword];\n    }\n    /**\n     * Check if the given term is protected in the context.\n     * @param {IJsonLdContextNormalizedRaw} context A context.\n     * @param {string} key A context term.\n     * @return {boolean} If the given term has an @protected flag.\n     */\n    static isTermProtected(context, key) {\n        const value = context[key];\n        return !(typeof value === 'string') && value && value['@protected'];\n    }\n    /**\n     * Check if the given context has at least one protected term.\n     * @param context A context.\n     * @return If the context has a protected term.\n     */\n    static hasProtectedTerms(context) {\n        for (const key of Object.keys(context)) {\n            if (Util.isTermProtected(context, key)) {\n                return true;\n            }\n        }\n        return false;\n    }\n    /**\n     * Check if the given key is an internal reserved keyword.\n     * @param key A context key.\n     */\n    static isReservedInternalKeyword(key) {\n        return key.startsWith('@__');\n    }\n}\nexports.Util = Util;\n// Regex for valid IRIs\nUtil.IRI_REGEX = /^([A-Za-z][A-Za-z0-9+-.]*|_):[^ \"<>{}|\\\\\\[\\]`#]*(#[^#]*)?$/;\n// Weaker regex for valid IRIs, this includes relative IRIs\nUtil.IRI_REGEX_WEAK = /(?::[^:])|\\//;\n// Regex for keyword form\nUtil.KEYWORD_REGEX = /^@[a-z]+$/i;\n// Regex to see if an IRI ends with a gen-delim character (see RFC 3986)\nUtil.ENDS_WITH_GEN_DELIM = /[:/?#\\[\\]@]$/;\n// Regex for language tags\nUtil.REGEX_LANGUAGE_TAG = /^[a-zA-Z]+(-[a-zA-Z0-9]+)*$/;\n// Regex for base directions\nUtil.REGEX_DIRECTION_TAG = /^(ltr)|(rtl)$/;\n// All known valid JSON-LD keywords\n// @see https://www.w3.org/TR/json-ld11/#keywords\nUtil.VALID_KEYWORDS = {\n    '@base': true,\n    '@container': true,\n    '@context': true,\n    '@direction': true,\n    '@graph': true,\n    '@id': true,\n    '@import': true,\n    '@included': true,\n    '@index': true,\n    '@json': true,\n    '@language': true,\n    '@list': true,\n    '@nest': true,\n    '@none': true,\n    '@prefix': true,\n    '@propagate': true,\n    '@protected': true,\n    '@reverse': true,\n    '@set': true,\n    '@type': true,\n    '@value': true,\n    '@version': true,\n    '@vocab': true,\n};\n// Keys in the contexts that will not be expanded based on the base IRI\nUtil.EXPAND_KEYS_BLACKLIST = [\n    '@base',\n    '@vocab',\n    '@language',\n    '@version',\n    '@direction',\n];\n// Keys in the contexts that may not be aliased from\nUtil.ALIAS_DOMAIN_BLACKLIST = [\n    '@container',\n    '@graph',\n    '@id',\n    '@index',\n    '@list',\n    '@nest',\n    '@none',\n    '@prefix',\n    '@reverse',\n    '@set',\n    '@type',\n    '@value',\n    '@version',\n];\n// Keys in the contexts that may not be aliased to\nUtil.ALIAS_RANGE_BLACKLIST = [\n    '@context',\n    '@preserve',\n];\n// All valid @container values\nUtil.CONTAINERS = [\n    '@list',\n    '@set',\n    '@index',\n    '@language',\n    '@graph',\n    '@id',\n    '@type',\n];\n// All valid @container values under processing mode 1.0\nUtil.CONTAINERS_1_0 = [\n    '@list',\n    '@set',\n    '@index',\n];\n//# sourceMappingURL=Util.js.map","/* jshint esversion: 6 */\n/* jslint node: true */\n'use strict';\n\nmodule.exports = function serialize (object) {\n  if (object === null || typeof object !== 'object' || object.toJSON != null) {\n    return JSON.stringify(object);\n  }\n\n  if (Array.isArray(object)) {\n    return '[' + object.reduce((t, cv, ci) => {\n      const comma = ci === 0 ? '' : ',';\n      const value = cv === undefined || typeof cv === 'symbol' ? null : cv;\n      return t + comma + serialize(value);\n    }, '') + ']';\n  }\n\n  return '{' + Object.keys(object).sort().reduce((t, cv, ci) => {\n    if (object[cv] === undefined ||\n        typeof object[cv] === 'symbol') {\n      return t;\n    }\n    const comma = t.length === 0 ? '' : ',';\n    return t + comma + serialize(cv) + ':' + serialize(object[cv]);\n  }, '') + '}';\n};\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n//# sourceMappingURL=IDocumentLoader.js.map","\"use strict\";\n// tslint:disable:max-line-length\nObject.defineProperty(exports, \"__esModule\", { value: true });\n//# sourceMappingURL=JsonLdContext.js.map","export class MapSet extends Map {\n  set(key, value) {\n    super.set(key, value);\n    return value;\n  }\n}\n\nexport class WeakMapSet extends WeakMap {\n  set(key, value) {\n    super.set(key, value);\n    return value;\n  }\n}\n","/*! (c) Andrea Giammarchi - ISC */\nconst empty = /^(?:area|base|br|col|embed|hr|img|input|keygen|link|menuitem|meta|param|source|track|wbr)$/i;\nconst elements = /<([a-z]+[a-z0-9:._-]*)([^>]*?)(\\/?)>/g;\nconst attributes = /([^\\s\\\\>\"'=]+)\\s*=\\s*(['\"]?)\\x01/g;\nconst holes = /[\\x01\\x02]/g;\n\n// \\x01 Node.ELEMENT_NODE\n// \\x02 Node.ATTRIBUTE_NODE\n\n/**\n * Given a template, find holes as both nodes and attributes and\n * return a string with holes as either comment nodes or named attributes.\n * @param {string[]} template a template literal tag array\n * @param {string} prefix prefix to use per each comment/attribute\n * @param {boolean} svg enforces self-closing tags\n * @returns {string} X/HTML with prefixed comments or attributes\n */\nexport default (template, prefix, svg) => {\n  let i = 0;\n  return template\n          .join('\\x01')\n          .trim()\n          .replace(\n            elements,\n            (_, name, attrs, selfClosing) => {\n              let ml = name + attrs.replace(attributes, '\\x02=$2$1').trimEnd();\n              if (selfClosing.length)\n                ml += (svg || empty.test(name)) ? ' /' : ('></' + name);\n              return '<' + ml + '>';\n            }\n          )\n          .replace(\n            holes,\n            hole => hole === '\\x01' ?\n              ('<!--' + prefix + i++ + '-->') :\n              (prefix + i++)\n          );\n};\n","const ELEMENT_NODE = 1;\nconst nodeType = 111;\n\nconst remove = ({firstChild, lastChild}) => {\n  const range = document.createRange();\n  range.setStartAfter(firstChild);\n  range.setEndAfter(lastChild);\n  range.deleteContents();\n  return firstChild;\n};\n\nexport const diffable = (node, operation) => node.nodeType === nodeType ?\n  ((1 / operation) < 0 ?\n    (operation ? remove(node) : node.lastChild) :\n    (operation ? node.valueOf() : node.firstChild)) :\n  node\n;\n\nexport const persistent = fragment => {\n  const {firstChild, lastChild} = fragment;\n  if (firstChild === lastChild)\n    return lastChild || fragment;\n  const {childNodes} = fragment;\n  const nodes = [...childNodes];\n  return {\n    ELEMENT_NODE,\n    nodeType,\n    firstChild,\n    lastChild,\n    valueOf() {\n      if (childNodes.length !== nodes.length)\n        fragment.append(...nodes);\n      return fragment;\n    }\n  };\n};\n","const {isArray} = Array;\nconst {indexOf, slice} = [];\n\nexport {isArray, indexOf, slice};\n","import {isArray} from 'uarray';\n\n// flag for foreign checks (slower path, fast by default)\nlet useForeign = false;\n\nexport class Foreign {\n  constructor(handler, value) {\n    useForeign = true;\n    this._ = (...args) => handler(...args, value);\n  }\n}\n\nexport const foreign = (handler, value) => new Foreign(handler, value);\n\nexport const aria = node => values => {\n  for (const key in values) {\n    const name = key === 'role' ? key : `aria-${key}`;\n    const value = values[key];\n    if (value == null)\n      node.removeAttribute(name);\n    else\n      node.setAttribute(name, value);\n  }\n};\n\nexport const attribute = (node, name) => {\n  let oldValue, orphan = true;\n  const attributeNode = document.createAttributeNS(null, name);\n  return newValue => {\n    if (oldValue !== newValue) {\n      oldValue = newValue;\n      if (oldValue == null) {\n        if (!orphan) {\n          node.removeAttributeNode(attributeNode);\n          orphan = true;\n        }\n      }\n      else {\n        const value = useForeign && (newValue instanceof Foreign) ?\n                        newValue._(node, name) : newValue;\n        if (value == null) {\n          if (!orphan)\n            node.removeAttributeNode(attributeNode);\n            orphan = true;\n        }\n        else {\n          attributeNode.value = value;\n          if (orphan) {\n            node.setAttributeNodeNS(attributeNode);\n            orphan = false;\n          }\n        }\n      }\n    }\n  };\n};\n\nexport const boolean = (node, key, oldValue) => newValue => {\n  if (oldValue !== !!newValue) {\n    // when IE won't be around anymore ...\n    // node.toggleAttribute(key, oldValue = !!newValue);\n    if ((oldValue = !!newValue))\n      node.setAttribute(key, '');\n    else\n      node.removeAttribute(key);\n  }\n};\n\nexport const data = ({dataset}) => values => {\n  for (const key in values) {\n    const value = values[key];\n    if (value == null)\n      delete dataset[key];\n    else\n      dataset[key] = value;\n  }\n};\n\nexport const event = (node, name) => {\n  let oldValue, lower, type = name.slice(2);\n  if (!(name in node) && (lower = name.toLowerCase()) in node)\n    type = lower.slice(2);\n  return newValue => {\n    const info = isArray(newValue) ? newValue : [newValue, false];\n    if (oldValue !== info[0]) {\n      if (oldValue)\n        node.removeEventListener(type, oldValue, info[1]);\n      if (oldValue = info[0])\n        node.addEventListener(type, oldValue, info[1]);\n    }\n  };\n};\n\nexport const ref = node => {\n  let oldValue;\n  return value => {\n    if (oldValue !== value) {\n      oldValue = value;\n      if (typeof value === 'function')\n        value(node);\n      else\n        value.current = node;\n    }\n  };\n};\n\nexport const setter = (node, key) => key === 'dataset' ?\n  data(node) :\n  value => {\n    node[key] = value;\n  };\n\nexport const text = node => {\n  let oldValue;\n  return newValue => {\n    if (oldValue != newValue) {\n      oldValue = newValue;\n      node.textContent = newValue == null ? '' : newValue;\n    }\n  };\n};\n","/**\n * ISC License\n *\n * Copyright (c) 2020, Andrea Giammarchi, @WebReflection\n *\n * Permission to use, copy, modify, and/or distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\n * REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\n * AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\n * INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\n * LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE\n * OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\n * PERFORMANCE OF THIS SOFTWARE.\n */\n\n/**\n * @param {Node} parentNode The container where children live\n * @param {Node[]} a The list of current/live children\n * @param {Node[]} b The list of future children\n * @param {(entry: Node, action: number) => Node} get\n * The callback invoked per each entry related DOM operation.\n * @param {Node} [before] The optional node used as anchor to insert before.\n * @returns {Node[]} The same list of future children.\n */\nexport default (parentNode, a, b, get, before) => {\n  const bLength = b.length;\n  let aEnd = a.length;\n  let bEnd = bLength;\n  let aStart = 0;\n  let bStart = 0;\n  let map = null;\n  while (aStart < aEnd || bStart < bEnd) {\n    // append head, tail, or nodes in between: fast path\n    if (aEnd === aStart) {\n      // we could be in a situation where the rest of nodes that\n      // need to be added are not at the end, and in such case\n      // the node to `insertBefore`, if the index is more than 0\n      // must be retrieved, otherwise it's gonna be the first item.\n      const node = bEnd < bLength ?\n        (bStart ?\n          (get(b[bStart - 1], -0).nextSibling) :\n          get(b[bEnd - bStart], 0)) :\n        before;\n      while (bStart < bEnd)\n        parentNode.insertBefore(get(b[bStart++], 1), node);\n    }\n    // remove head or tail: fast path\n    else if (bEnd === bStart) {\n      while (aStart < aEnd) {\n        // remove the node only if it's unknown or not live\n        if (!map || !map.has(a[aStart]))\n          parentNode.removeChild(get(a[aStart], -1));\n        aStart++;\n      }\n    }\n    // same node: fast path\n    else if (a[aStart] === b[bStart]) {\n      aStart++;\n      bStart++;\n    }\n    // same tail: fast path\n    else if (a[aEnd - 1] === b[bEnd - 1]) {\n      aEnd--;\n      bEnd--;\n    }\n    // The once here single last swap \"fast path\" has been removed in v1.1.0\n    // https://github.com/WebReflection/udomdiff/blob/single-final-swap/esm/index.js#L69-L85\n    // reverse swap: also fast path\n    else if (\n      a[aStart] === b[bEnd - 1] &&\n      b[bStart] === a[aEnd - 1]\n    ) {\n      // this is a \"shrink\" operation that could happen in these cases:\n      // [1, 2, 3, 4, 5]\n      // [1, 4, 3, 2, 5]\n      // or asymmetric too\n      // [1, 2, 3, 4, 5]\n      // [1, 2, 3, 5, 6, 4]\n      const node = get(a[--aEnd], -1).nextSibling;\n      parentNode.insertBefore(\n        get(b[bStart++], 1),\n        get(a[aStart++], -1).nextSibling\n      );\n      parentNode.insertBefore(get(b[--bEnd], 1), node);\n      // mark the future index as identical (yeah, it's dirty, but cheap 👍)\n      // The main reason to do this, is that when a[aEnd] will be reached,\n      // the loop will likely be on the fast path, as identical to b[bEnd].\n      // In the best case scenario, the next loop will skip the tail,\n      // but in the worst one, this node will be considered as already\n      // processed, bailing out pretty quickly from the map index check\n      a[aEnd] = b[bEnd];\n    }\n    // map based fallback, \"slow\" path\n    else {\n      // the map requires an O(bEnd - bStart) operation once\n      // to store all future nodes indexes for later purposes.\n      // In the worst case scenario, this is a full O(N) cost,\n      // and such scenario happens at least when all nodes are different,\n      // but also if both first and last items of the lists are different\n      if (!map) {\n        map = new Map;\n        let i = bStart;\n        while (i < bEnd)\n          map.set(b[i], i++);\n      }\n      // if it's a future node, hence it needs some handling\n      if (map.has(a[aStart])) {\n        // grab the index of such node, 'cause it might have been processed\n        const index = map.get(a[aStart]);\n        // if it's not already processed, look on demand for the next LCS\n        if (bStart < index && index < bEnd) {\n          let i = aStart;\n          // counts the amount of nodes that are the same in the future\n          let sequence = 1;\n          while (++i < aEnd && i < bEnd && map.get(a[i]) === (index + sequence))\n            sequence++;\n          // effort decision here: if the sequence is longer than replaces\n          // needed to reach such sequence, which would brings again this loop\n          // to the fast path, prepend the difference before a sequence,\n          // and move only the future list index forward, so that aStart\n          // and bStart will be aligned again, hence on the fast path.\n          // An example considering aStart and bStart are both 0:\n          // a: [1, 2, 3, 4]\n          // b: [7, 1, 2, 3, 6]\n          // this would place 7 before 1 and, from that time on, 1, 2, and 3\n          // will be processed at zero cost\n          if (sequence > (index - bStart)) {\n            const node = get(a[aStart], 0);\n            while (bStart < index)\n              parentNode.insertBefore(get(b[bStart++], 1), node);\n          }\n          // if the effort wasn't good enough, fallback to a replace,\n          // moving both source and target indexes forward, hoping that some\n          // similar node will be found later on, to go back to the fast path\n          else {\n            parentNode.replaceChild(\n              get(b[bStart++], 1),\n              get(a[aStart++], -1)\n            );\n          }\n        }\n        // otherwise move the source forward, 'cause there's nothing to do\n        else\n          aStart++;\n      }\n      // this node has no meaning in the future list, so it's more than safe\n      // to remove it, and check the next live node out instead, meaning\n      // that only the live list index should be forwarded\n      else\n        parentNode.removeChild(get(a[aStart++], -1));\n    }\n  }\n  return b;\n};\n","const {isArray, prototype} = Array;\nconst {indexOf} = prototype;\n\nexport {isArray, indexOf};\n\nconst {\n  createDocumentFragment,\n  createElement,\n  createElementNS,\n  createTextNode,\n  createTreeWalker,\n  importNode\n} = new Proxy(document, {\n  get: (target, method) => target[method].bind(target)\n});\n\nexport {createTextNode, createTreeWalker, importNode};\n\nconst createHTML = html => {\n  const template = createElement('template');\n  template.innerHTML = html;\n  return template.content;\n};\n\nlet xml;\nconst createSVG = svg => {\n  if (!xml) xml = createElementNS('http://www.w3.org/2000/svg', 'svg');\n  xml.innerHTML = svg;\n  const content = createDocumentFragment();\n  content.append(...xml.childNodes);\n  return content;\n};\n\nexport const createContent = (text, svg) => svg ?\n                              createSVG(text) : createHTML(text);\n","import {diffable} from '@webreflection/uwire';\n\nimport {aria, attribute, boolean, event, ref, setter, text} from 'uhandlers';\nimport udomdiff from 'udomdiff';\n\nimport {isArray, createTextNode} from './utils.js';\n\n// from a generic path, retrieves the exact targeted node\nconst reducePath = ({childNodes}, i) => childNodes[i];\n\n// this helper avoid code bloat around handleAnything() callback\nconst diff = (comment, oldNodes, newNodes) => udomdiff(\n  comment.parentNode,\n  // TODO: there is a possible edge case where a node has been\n  //       removed manually, or it was a keyed one, attached\n  //       to a shared reference between renders.\n  //       In this case udomdiff might fail at removing such node\n  //       as its parent won't be the expected one.\n  //       The best way to avoid this issue is to filter oldNodes\n  //       in search of those not live, or not in the current parent\n  //       anymore, but this would require both a change to uwire,\n  //       exposing a parentNode from the firstChild, as example,\n  //       but also a filter per each diff that should exclude nodes\n  //       that are not in there, penalizing performance quite a lot.\n  //       As this has been also a potential issue with domdiff,\n  //       and both lighterhtml and hyperHTML might fail with this\n  //       very specific edge case, I might as well document this possible\n  //       \"diffing shenanigan\" and call it a day.\n  oldNodes,\n  newNodes,\n  diffable,\n  comment\n);\n\n// if an interpolation represents a comment, the whole\n// diffing will be related to such comment.\n// This helper is in charge of understanding how the new\n// content for such interpolation/hole should be updated\nconst handleAnything = comment => {\n  let oldValue, text, nodes = [];\n  const anyContent = newValue => {\n    switch (typeof newValue) {\n      // primitives are handled as text content\n      case 'string':\n      case 'number':\n      case 'boolean':\n        if (oldValue !== newValue) {\n          oldValue = newValue;\n          if (!text)\n            text = createTextNode('');\n          text.data = newValue;\n          nodes = diff(comment, nodes, [text]);\n        }\n        break;\n      // null, and undefined are used to cleanup previous content\n      case 'object':\n      case 'undefined':\n        if (newValue == null) {\n          if (oldValue != newValue) {\n            oldValue = newValue;\n            nodes = diff(comment, nodes, []);\n          }\n          break;\n        }\n        // arrays and nodes have a special treatment\n        if (isArray(newValue)) {\n          oldValue = newValue;\n          // arrays can be used to cleanup, if empty\n          if (newValue.length === 0)\n            nodes = diff(comment, nodes, []);\n          // or diffed, if these contains nodes or \"wires\"\n          else if (typeof newValue[0] === 'object')\n            nodes = diff(comment, nodes, newValue);\n          // in all other cases the content is stringified as is\n          else\n            anyContent(String(newValue));\n          break;\n        }\n        // if the new value is a DOM node, or a wire, and it's\n        // different from the one already live, then it's diffed.\n        // if the node is a fragment, it's appended once via its childNodes\n        // There is no `else` here, meaning if the content\n        // is not expected one, nothing happens, as easy as that.\n        if (oldValue !== newValue && 'ELEMENT_NODE' in newValue) {\n          oldValue = newValue;\n          nodes = diff(\n            comment,\n            nodes,\n            newValue.nodeType === 11 ?\n              [...newValue.childNodes] :\n              [newValue]\n          );\n        }\n        break;\n      case 'function':\n        anyContent(newValue(comment));\n        break;\n    }\n  };\n  return anyContent;\n};\n\n// attributes can be:\n//  * ref=${...}      for hooks and other purposes\n//  * aria=${...}     for aria attributes\n//  * ?boolean=${...} for boolean attributes\n//  * .dataset=${...} for dataset related attributes\n//  * .setter=${...}  for Custom Elements setters or nodes with setters\n//                    such as buttons, details, options, select, etc\n//  * @event=${...}   to explicitly handle event listeners\n//  * onevent=${...}  to automatically handle event listeners\n//  * generic=${...}  to handle an attribute just like an attribute\nconst handleAttribute = (node, name/*, svg*/) => {\n  switch (name[0]) {\n    case '?': return boolean(node, name.slice(1), false);\n    case '.': return setter(node, name.slice(1));\n    case '@': return event(node, 'on' + name.slice(1));\n    case 'o': if (name[1] === 'n') return event(node, name);\n  }\n\n  switch (name) {\n    case 'ref': return ref(node);\n    case 'aria': return aria(node);\n  }\n\n  return attribute(node, name/*, svg*/);\n};\n\n// each mapped update carries the update type and its path\n// the type is either node, attribute, or text, while\n// the path is how to retrieve the related node to update.\n// In the attribute case, the attribute name is also carried along.\nexport function handlers(options) {\n  const {type, path} = options;\n  const node = path.reduceRight(reducePath, this);\n  return type === 'node' ?\n    handleAnything(node) :\n    (type === 'attr' ?\n      handleAttribute(node, options.name/*, options.svg*/) :\n      text(node));\n};\n","import {WeakMapSet} from '@webreflection/mapset';\nimport instrument from '@webreflection/uparser';\nimport {persistent} from '@webreflection/uwire';\n\nimport {handlers} from './handlers.js';\nimport {isArray, indexOf, createContent, createTreeWalker, importNode} from './utils.js';\n\n// from a fragment container, create an array of indexes\n// related to its child nodes, so that it's possible\n// to retrieve later on exact node via reducePath\nconst createPath = node => {\n  const path = [];\n  let {parentNode} = node;\n  while (parentNode) {\n    path.push(indexOf.call(parentNode.childNodes, node));\n    node = parentNode;\n    ({parentNode} = node);\n  }\n  return path;\n};\n\n// the prefix is used to identify either comments, attributes, or nodes\n// that contain the related unique id. In the attribute cases\n// isµX=\"attribute-name\" will be used to map current X update to that\n// attribute name, while comments will be like <!--isµX-->, to map\n// the update to that specific comment node, hence its parent.\n// style and textarea will have <!--isµX--> text content, and are handled\n// directly through text-only updates.\nconst prefix = 'isµ';\n\n// Template Literals are unique per scope and static, meaning a template\n// should be parsed once, and once only, as it will always represent the same\n// content, within the exact same amount of updates each time.\n// This cache relates each template to its unique content and updates.\nconst cache = new WeakMapSet;\n\n// a RegExp that helps checking nodes that cannot contain comments\nconst textOnly = /^(?:textarea|script|style|title|plaintext|xmp)$/;\n\nexport const createCache = () => ({\n  stack: [],    // each template gets a stack for each interpolation \"hole\"\n\n  entry: null,  // each entry contains details, such as:\n                //  * the template that is representing\n                //  * the type of node it represents (html or svg)\n                //  * the content fragment with all nodes\n                //  * the list of updates per each node (template holes)\n                //  * the \"wired\" node or fragment that will get updates\n                // if the template or type are different from the previous one\n                // the entry gets re-created each time\n\n  wire: null    // each rendered node represent some wired content and\n                // this reference to the latest one. If different, the node\n                // will be cleaned up and the new \"wire\" will be appended\n});\n\n// the entry stored in the rendered node cache, and per each \"hole\"\nconst createEntry = (type, template) => {\n  const {content, updates} = mapUpdates(type, template);\n  return {type, template, content, updates, wire: null};\n};\n\n// a template is instrumented to be able to retrieve where updates are needed.\n// Each unique template becomes a fragment, cloned once per each other\n// operation based on the same template, i.e. data => html`<p>${data}</p>`\nconst mapTemplate = (type, template) => {\n  const svg = type === 'svg';\n  const text = instrument(template, prefix, svg);\n  const content = createContent(text, svg);\n  // once instrumented and reproduced as fragment, it's crawled\n  // to find out where each update is in the fragment tree\n  const tw = createTreeWalker(content, 1 | 128);\n  const nodes = [];\n  const length = template.length - 1;\n  let i = 0;\n  // updates are searched via unique names, linearly increased across the tree\n  // <div isµ0=\"attr\" isµ1=\"other\"><!--isµ2--><style><!--isµ3--</style></div>\n  let search = `${prefix}${i}`;\n  while (i < length) {\n    const node = tw.nextNode();\n    // if not all updates are bound but there's nothing else to crawl\n    // it means that there is something wrong with the template.\n    if (!node)\n      throw `bad template: ${text}`;\n    // if the current node is a comment, and it contains isµX\n    // it means the update should take care of any content\n    if (node.nodeType === 8) {\n      // The only comments to be considered are those\n      // which content is exactly the same as the searched one.\n      if (node.data === search) {\n        nodes.push({type: 'node', path: createPath(node)});\n        search = `${prefix}${++i}`;\n      }\n    }\n    else {\n      // if the node is not a comment, loop through all its attributes\n      // named isµX and relate attribute updates to this node and the\n      // attribute name, retrieved through node.getAttribute(\"isµX\")\n      // the isµX attribute will be removed as irrelevant for the layout\n      // let svg = -1;\n      while (node.hasAttribute(search)) {\n        nodes.push({\n          type: 'attr',\n          path: createPath(node),\n          name: node.getAttribute(search)\n        });\n        node.removeAttribute(search);\n        search = `${prefix}${++i}`;\n      }\n      // if the node was a style, textarea, or others, check its content\n      // and if it is <!--isµX--> then update tex-only this node\n      if (\n        textOnly.test(node.localName) &&\n        node.textContent.trim() === `<!--${search}-->`\n      ){\n        node.textContent = '';\n        nodes.push({type: 'text', path: createPath(node)});\n        search = `${prefix}${++i}`;\n      }\n    }\n  }\n  // once all nodes to update, or their attributes, are known, the content\n  // will be cloned in the future to represent the template, and all updates\n  // related to such content retrieved right away without needing to re-crawl\n  // the exact same template, and its content, more than once.\n  return {content, nodes};\n};\n\n// if a template is unknown, perform the previous mapping, otherwise grab\n// its details such as the fragment with all nodes, and updates info.\nconst mapUpdates = (type, template) => {\n  const {content, nodes} = (\n    cache.get(template) ||\n    cache.set(template, mapTemplate(type, template))\n  );\n  // clone deeply the fragment\n  const fragment = importNode(content, true);\n  // and relate an update handler per each node that needs one\n  const updates = nodes.map(handlers, fragment);\n  // return the fragment and all updates to use within its nodes\n  return {content: fragment, updates};\n};\n\n// as html and svg can be nested calls, but no parent node is known\n// until rendered somewhere, the unroll operation is needed to\n// discover what to do with each interpolation, which will result\n// into an update operation.\nexport const unroll = (info, {type, template, values}) => {\n  // interpolations can contain holes and arrays, so these need\n  // to be recursively discovered\n  const length = unrollValues(info, values);\n  let {entry} = info;\n  // if the cache entry is either null or different from the template\n  // and the type this unroll should resolve, create a new entry\n  // assigning a new content fragment and the list of updates.\n  if (!entry || (entry.template !== template || entry.type !== type))\n    info.entry = (entry = createEntry(type, template));\n  const {content, updates, wire} = entry;\n  // even if the fragment and its nodes is not live yet,\n  // it is already possible to update via interpolations values.\n  for (let i = 0; i < length; i++)\n    updates[i](values[i]);\n  // if the entry was new, or representing a different template or type,\n  // create a new persistent entity to use during diffing.\n  // This is simply a DOM node, when the template has a single container,\n  // as in `<p></p>`, or a \"wire\" in `<p></p><p></p>` and similar cases.\n  return wire || (entry.wire = persistent(content));\n};\n\n// the stack retains, per each interpolation value, the cache\n// related to each interpolation value, or null, if the render\n// was conditional and the value is not special (Array or Hole)\nconst unrollValues = ({stack}, values) => {\n  const {length} = values;\n  for (let i = 0; i < length; i++) {\n    const hole = values[i];\n    // each Hole gets unrolled and re-assigned as value\n    // so that domdiff will deal with a node/wire, not with a hole\n    if (hole instanceof Hole)\n      values[i] = unroll(\n        stack[i] || (stack[i] = createCache()),\n        hole\n      );\n    // arrays are recursively resolved so that each entry will contain\n    // also a DOM node or a wire, hence it can be diffed if/when needed\n    else if (isArray(hole))\n      unrollValues(stack[i] || (stack[i] = createCache()), hole);\n    // if the value is nothing special, the stack doesn't need to retain data\n    // this is useful also to cleanup previously retained data, if the value\n    // was a Hole, or an Array, but not anymore, i.e.:\n    // const update = content => html`<div>${content}</div>`;\n    // update(listOfItems); update(null); update(html`hole`)\n    else\n      stack[i] = null;\n  }\n  if (length < stack.length)\n    stack.splice(length);\n  return length;\n};\n\n/**\n * Holds all details wrappers needed to render the content further on.\n * @constructor\n * @param {string} type The hole type, either `html` or `svg`.\n * @param {string[]} template The template literals used to the define the content.\n * @param {Array} values Zero, one, or more interpolated values to render.\n */\nexport class Hole {\n  constructor(type, template, values) {\n    this.type = type;\n    this.template = template;\n    this.values = values;\n  }\n};\n","import {MapSet, WeakMapSet} from '@webreflection/mapset';\n\nimport {Hole, createCache, unroll} from './rabbit.js';\n\n// both `html` and `svg` template literal tags are polluted\n// with a `for(ref[, id])` and a `node` tag too\nconst tag = type => {\n  // both `html` and `svg` tags have their own cache\n  const keyed = new WeakMapSet;\n  // keyed operations always re-use the same cache and unroll\n  // the template and its interpolations right away\n  const fixed = cache => (template, ...values) => unroll(\n    cache,\n    {type, template, values}\n  );\n  return Object.assign(\n    // non keyed operations are recognized as instance of Hole\n    // during the \"unroll\", recursively resolved and updated\n    (template, ...values) => new Hole(type, template, values),\n    {\n      // keyed operations need a reference object, usually the parent node\n      // which is showing keyed results, and optionally a unique id per each\n      // related node, handy with JSON results and mutable list of objects\n      // that usually carry a unique identifier\n      for(ref, id) {\n        const memo = keyed.get(ref) || keyed.set(ref, new MapSet);\n        return memo.get(id) || memo.set(id, fixed(createCache()));\n      },\n      // it is possible to create one-off content out of the box via node tag\n      // this might return the single created node, or a fragment with all\n      // nodes present at the root level and, of course, their child nodes\n      node: (template, ...values) => unroll(createCache(), new Hole(type, template, values)).valueOf()\n    }\n  );\n};\n\n// each rendered node gets its own cache\nconst cache = new WeakMapSet;\n\n// rendering means understanding what `html` or `svg` tags returned\n// and it relates a specific node to its own unique cache.\n// Each time the content to render changes, the node is cleaned up\n// and the new new content is appended, and if such content is a Hole\n// then it's \"unrolled\" to resolve all its inner nodes.\nconst render = (where, what) => {\n  const hole = typeof what === 'function' ? what() : what;\n  const info = cache.get(where) || cache.set(where, createCache());\n  const wire = hole instanceof Hole ? unroll(info, hole) : hole;\n  if (wire !== info.wire) {\n    info.wire = wire;\n    // valueOf() simply returns the node itself, but in case it was a \"wire\"\n    // it will eventually re-append all nodes to its fragment so that such\n    // fragment can be re-appended many times in a meaningful way\n    // (wires are basically persistent fragments facades with special behavior)\n    where.replaceChildren(wire.valueOf());\n  }\n  return where;\n};\n\nconst html = tag('html');\nconst svg = tag('svg');\n\nexport {Hole, render, html, svg};\n","\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__exportStar(require(\"./lib/ContextParser\"), exports);\n__exportStar(require(\"./lib/ErrorCoded\"), exports);\n__exportStar(require(\"./lib/FetchDocumentLoader\"), exports);\n__exportStar(require(\"./lib/IDocumentLoader\"), exports);\n__exportStar(require(\"./lib/JsonLdContext\"), exports);\n__exportStar(require(\"./lib/JsonLdContextNormalized\"), exports);\n__exportStar(require(\"./lib/Util\"), exports);\n//# sourceMappingURL=index.js.map","export const loaders = new WeakMap()\n\nexport const withLoader = (promise, loader) => {\n  loaders.set(promise, loader)\n  return promise\n}\n","export const preloadPaths = async (paths) => {\n  const pathSubjects = new Map()\n\n  const filteredPaths = (await Promise.all(paths.map(async path => {\n    return await path.path\n  }))).filter(path => {\n    return !path.resultsCache\n  })\n  .map(path => path.proxy)\n\n  for (const path of filteredPaths) {\n    const subject = await (await path.subject).value\n    if (!pathSubjects.has(subject)) pathSubjects.set(subject, [])\n    const pathParts = pathSubjects.get(subject)\n    pathParts.push(path)\n  }\n\n  for (const pathParts of pathSubjects.values()) {\n    const pathExpressions = (await Promise.all(\n      pathParts.map(value => value.pathExpression)\n    )).map(pathExpression => {\n      return pathExpression.filter(item => item.predicate).map(item => item.predicate.value)\n    }).map(pathExpression => {\n      const parts = pathExpression.map(part => part.startsWith('http') ? `<${part}>` : part)\n      return parts.join(' / ')\n    })\n    .filter(Boolean)\n\n    const object = pathParts[0].parent\n\n    if (object) {\n      try {\n        object.finalClause = (variable) => `VALUES ${variable} { <${object.subject.value}> }`\n        await object.proxy.preload(...pathExpressions)\n  \n        for (const path of pathParts) {\n          const predicate = await (await path?.predicate)?.value\n          if (predicate) {\n            const cache = object.resultsCache[0].path.propertyCache[predicate]\n            path.path.resultsCache = cache  \n          }\n        }\n      }\n      catch (exception) {\n        console.log(exception)\n      }  \n    } \n  }\n}","const EMPTY = Object.create(null);\n/**\n * A PathProxy creates path expressions,\n * to which functionality can be attached.\n *\n * To users, these paths act as regular JavaScript objects\n * (such as `path.foo.bar.prop`) thanks to Proxy.\n * Behind the scenes, they carry around internal data\n * that can be used to influence their functionality.\n *\n * A path's functionality is realized by:\n * - handlers, which handle a specific named property\n * - resolvers, which can handle arbitrary properties\n * Only handlers and resolvers see the internal data.\n *\n * A path can have arbitrary internal data fields, but these are reserved:\n * - settings, an object that is passed on as-is to child paths\n * - proxy, a reference to the proxied object the user sees\n * - parent, a reference to the parent path\n * - apply, a function the will be invoked when the path is called as a function\n * - extendPath, a method to create a child path with this path as parent\n */\n\nexport default class PathProxy {\n  constructor() {\n    let {\n      handlers = EMPTY,\n      resolvers = []\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    this._handlers = handlers;\n    this._resolvers = resolvers;\n  }\n  /**\n   * Creates a path Proxy with the given settings and internal data fields.\n   */\n\n\n  createPath() {\n    let settings = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    let data = arguments.length > 1 ? arguments[1] : undefined;\n    // The settings parameter is optional\n    if (data === undefined) [data, settings] = [settings, {}]; // Create the path's internal data object and the proxy that wraps it\n\n    const {\n      apply,\n      ...rawData\n    } = data;\n    const path = apply ? Object.assign(callPathFunction, rawData) : rawData;\n    const proxy = new Proxy(path, this);\n    path.proxy = proxy;\n    path.settings = settings;\n\n    function callPathFunction() {\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n\n      return apply(args, path, proxy);\n    } // Add an extendPath method to create child paths\n\n\n    if (!path.extendPath) {\n      const pathProxy = this;\n\n      path.extendPath = function extendPath(newData) {\n        let parent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this;\n        return pathProxy.createPath(settings, {\n          parent,\n          extendPath,\n          ...newData\n        });\n      };\n    } // Return the proxied path\n\n\n    return proxy;\n  }\n  /**\n   * Handles access to a property\n   */\n\n\n  get(pathData, property) {\n    // Handlers provide functionality for a specific property,\n    // so check if we find a handler first\n    const handler = this._handlers[property];\n    if (handler && typeof handler.handle === 'function') return handler.handle(pathData, pathData.proxy); // Resolvers provide functionality for arbitrary properties,\n    // so find a resolver that can handle this property\n\n    for (const resolver of this._resolvers) {\n      if (resolver.supports(property)) return resolver.resolve(property, pathData, pathData.proxy);\n    } // Otherwise, the property does not exist\n\n\n    return undefined;\n  }\n\n}","class BlankNode {\n  constructor (id) {\n    this.value = id || ('b' + (++BlankNode.nextId))\n  }\n\n  equals (other) {\n    return !!other && other.termType === this.termType && other.value === this.value\n  }\n}\n\nBlankNode.prototype.termType = 'BlankNode'\n\nBlankNode.nextId = 0\n\nmodule.exports = BlankNode\n","class DefaultGraph {\n  equals (other) {\n    return !!other && other.termType === this.termType\n  }\n}\n\nDefaultGraph.prototype.termType = 'DefaultGraph'\nDefaultGraph.prototype.value = ''\n\nmodule.exports = DefaultGraph\n","function fromTerm (original) {\n  if (!original) {\n    return null\n  }\n\n  if (original.termType === 'BlankNode') {\n    return this.blankNode(original.value)\n  }\n\n  if (original.termType === 'DefaultGraph') {\n    return this.defaultGraph()\n  }\n\n  if (original.termType === 'Literal') {\n    return this.literal(original.value, original.language || this.namedNode(original.datatype.value))\n  }\n\n  if (original.termType === 'NamedNode') {\n    return this.namedNode(original.value)\n  }\n\n  if (original.termType === 'Quad') {\n    const subject = this.fromTerm(original.subject)\n    const predicate = this.fromTerm(original.predicate)\n    const object = this.fromTerm(original.object)\n    const graph = this.fromTerm(original.graph)\n\n    return this.quad(subject, predicate, object, graph)\n  }\n\n  if (original.termType === 'Variable') {\n    return this.variable(original.value)\n  }\n\n  throw new Error(`unknown termType ${original.termType}`)\n}\n\nmodule.exports = fromTerm\n","class NamedNode {\n  constructor (iri) {\n    this.value = iri\n  }\n\n  equals (other) {\n    return !!other && other.termType === this.termType && other.value === this.value\n  }\n}\n\nNamedNode.prototype.termType = 'NamedNode'\n\nmodule.exports = NamedNode\n","const NamedNode = require('./NamedNode.js')\n\nclass Literal {\n  constructor (value, language, datatype) {\n    this.value = value\n    this.datatype = Literal.stringDatatype\n    this.language = ''\n\n    if (language) {\n      this.language = language\n      this.datatype = Literal.langStringDatatype\n    } else if (datatype) {\n      this.datatype = datatype\n    }\n  }\n\n  equals (other) {\n    return !!other && other.termType === this.termType && other.value === this.value &&\n      other.language === this.language && other.datatype.equals(this.datatype)\n  }\n}\n\nLiteral.prototype.termType = 'Literal'\n\nLiteral.langStringDatatype = new NamedNode('http://www.w3.org/1999/02/22-rdf-syntax-ns#langString')\nLiteral.stringDatatype = new NamedNode('http://www.w3.org/2001/XMLSchema#string')\n\nmodule.exports = Literal\n","const DefaultGraph = require('./DefaultGraph.js')\n\nclass Quad {\n  constructor (subject, predicate, object, graph) {\n    this.subject = subject\n    this.predicate = predicate\n    this.object = object\n\n    if (graph) {\n      this.graph = graph\n    } else {\n      this.graph = new DefaultGraph()\n    }\n  }\n\n  equals (other) {\n    // `|| !other.termType` is for backwards-compatibility with old factories without RDF* support.\n    return !!other && (other.termType === 'Quad' || !other.termType) &&\n      other.subject.equals(this.subject) && other.predicate.equals(this.predicate) &&\n      other.object.equals(this.object) && other.graph.equals(this.graph)\n  }\n}\n\nQuad.prototype.termType = 'Quad'\nQuad.prototype.value = ''\n\nmodule.exports = Quad\n","class Variable {\n  constructor (name) {\n    this.value = name\n  }\n\n  equals (other) {\n    return !!other && other.termType === this.termType && other.value === this.value\n  }\n}\n\nVariable.prototype.termType = 'Variable'\n\nmodule.exports = Variable\n","const BlankNode = require('./BlankNode.js')\nconst DefaultGraph = require('./DefaultGraph.js')\nconst fromTermRaw = require('./fromTerm.js')\nconst Literal = require('./Literal.js')\nconst NamedNode = require('./NamedNode.js')\nconst Quad = require('./Quad.js')\nconst Variable = require('./Variable.js')\n\nfunction namedNode (value) {\n  return new NamedNode(value)\n}\n\nfunction blankNode (value) {\n  return new BlankNode(value)\n}\n\nfunction literal (value, languageOrDatatype) {\n  if (typeof languageOrDatatype === 'string') {\n    if (languageOrDatatype.indexOf(':') === -1) {\n      return new Literal(value, languageOrDatatype)\n    }\n\n    return new Literal(value, null, DataFactory.namedNode(languageOrDatatype))\n  }\n\n  return new Literal(value, null, languageOrDatatype)\n}\n\nfunction variable (value) {\n  return new Variable(value)\n}\n\nfunction defaultGraph () {\n  return DataFactory.defaultGraphInstance\n}\n\nfunction triple (subject, predicate, object) {\n  return DataFactory.quad(subject, predicate, object)\n}\n\nfunction quad (subject, predicate, object, graph) {\n  return new Quad(subject, predicate, object, graph || DataFactory.defaultGraphInstance)\n}\n\nfunction fromTerm (original) {\n  return fromTermRaw.call(DataFactory, original)\n}\n\nfunction fromQuad (original) {\n  return fromTermRaw.call(DataFactory, original)\n}\n\nconst DataFactory = {\n  namedNode,\n  blankNode,\n  literal,\n  variable,\n  defaultGraph,\n  triple,\n  quad,\n  fromTerm,\n  fromQuad,\n  defaultGraphInstance: new DefaultGraph()\n}\n\nmodule.exports = DataFactory\n","const DataFactory = require('./lib/DataFactory.js')\n\nmodule.exports = DataFactory\n","import { ContextParser } from 'jsonld-context-parser';\n/**\n * Used to share context between multiple resolvers\n */\n\nexport default class ContextProvider {\n  /**\n   * Creates a new resolver for the given context(s).\n   */\n  constructor() {\n    this._context = Promise.resolve({});\n    this.extendContext(...arguments);\n  }\n  /**\n   * Extends the current context with the given context(s).\n   */\n\n\n  async extendContext() {\n    for (var _len = arguments.length, contexts = new Array(_len), _key = 0; _key < _len; _key++) {\n      contexts[_key] = arguments[_key];\n    }\n\n    await (this._context = this._context.then(_ref => {\n      let {\n        contextRaw\n      } = _ref;\n      return new ContextParser().parse([contextRaw, ...contexts]);\n    }));\n  }\n\n}","const done = {};\n/**\n * Returns the elements of the iterable as an array\n */\n\nexport async function iterableToArray(iterable) {\n  const items = [];\n\n  for await (const item of iterable) items.push(item);\n\n  return items;\n}\n/**\n * Gets the first element of the iterable.\n */\n\nexport function getFirstItem(iterable) {\n  const iterator = iterable[Symbol.asyncIterator]();\n  return iterator.next().then(item => item.value);\n}\n/**\n * Creates an async iterator with the item as only element.\n */\n\nexport function iteratorFor(item) {\n  return {\n    async next() {\n      if (item !== done) {\n        const value = await item;\n        item = done;\n        return {\n          value\n        };\n      }\n\n      return {\n        done: true\n      };\n    }\n\n  };\n}","import { getFirstItem } from './iterableUtils';\n/**\n * Returns a lazy thenable to the created promise.\n */\n\nexport function lazyThenable(createPromise) {\n  return {\n    then: getThen(createPromise)\n  };\n}\n/**\n * Lazily returns the `then` function of the created promise.\n */\n\nexport function getThen(createPromise) {\n  return (onResolved, onRejected) => createPromise().then(onResolved, onRejected);\n}\n/**\n * Returns an iterable that is also a promise to the first element.\n */\n\nexport function toIterablePromise(iterable) {\n  // If called with a generator function,\n  // memoize it to enable multiple iterations\n  if (typeof iterable === 'function') iterable = memoizeIterable(iterable()); // Return an object that is iterable and a promise\n\n  return {\n    [Symbol.asyncIterator]() {\n      return iterable[Symbol.asyncIterator]();\n    },\n\n    get then() {\n      return getThen(() => getFirstItem(this));\n    },\n\n    catch(onRejected) {\n      return this.then(null, onRejected);\n    },\n\n    finally(callback) {\n      return this.then().finally(callback);\n    }\n\n  };\n}\n/**\n * Returns a memoized version of the iterable\n * that can be iterated over as many times as needed.\n */\n\nexport function memoizeIterable(iterable) {\n  const cache = [];\n  let iterator = iterable[Symbol.asyncIterator]();\n  return {\n    [Symbol.asyncIterator]() {\n      let i = 0;\n      return {\n        async next() {\n          // Return the item if it has been read already\n          if (i < cache.length) return cache[i++]; // Stop if there are no more items\n\n          if (!iterator) return {\n            done: true\n          }; // Read and cache an item from the iterable otherwise\n\n          const item = cache[i++] = iterator.next();\n          if ((await item).done) iterator = null;\n          return item;\n        }\n\n      };\n    }\n\n  };\n}","import { namedNode, literal } from '@rdfjs/data-model';\nconst xsd = 'http://www.w3.org/2001/XMLSchema#';\nconst xsdBoolean = `${xsd}boolean`;\nconst xsdDateTime = `${xsd}dateTime`;\nconst xsdDecimal = `${xsd}decimal`;\nconst xsdDouble = `${xsd}double`;\nconst xsdFloat = `${xsd}float`;\nconst xsdInteger = `${xsd}integer`;\nconst xsdBooleanTerm = namedNode(xsdBoolean);\nconst xsdDateTimeTerm = namedNode(xsdDateTime);\nconst xsdDecimalTerm = namedNode(xsdDecimal);\nconst xsdDoubleTerm = namedNode(xsdDouble);\nconst xsdIntegerTerm = namedNode(xsdInteger);\nconst xsdTrue = literal('true', xsdBooleanTerm);\nconst xsdFalse = literal('false', xsdBooleanTerm);\nconst xsdNaN = literal('NaN', xsdDoubleTerm);\nconst xsdInf = literal('INF', xsdDoubleTerm);\nconst xsdMinusInf = literal('-INF', xsdDoubleTerm);\nconst xsdPrimitives = {\n  NaN,\n  'INF': Infinity,\n  '-INF': -Infinity\n}; // Checks whether the value is asynchronously iterable\n\nexport function isAsyncIterable(value) {\n  return value && typeof value[Symbol.asyncIterator] === 'function';\n} // Checks whether the value is an object without special meaning to LDflex\n\nexport function isPlainObject(value) {\n  return value !== null && // Ignore non-objects\n  typeof value === 'object' && // Ignore arrays\n  !Array.isArray(value) && // Ignore dates\n  !(value instanceof Date) && // Ignore Promise instances\n  typeof value.then !== 'function' && // Ignore RDF/JS Term instances\n  typeof value.termType !== 'string' && // Ignore LDflex paths\n  !isAsyncIterable(value);\n} // Checks whether the arguments consist of exactly one plain object\n\nexport function hasPlainObjectArgs(args) {\n  let allowMultiple = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  const hasPlainObject = args.some(isPlainObject);\n  if (hasPlainObject && !allowMultiple && args.length !== 1) throw new Error(`Expected only 1 plain object, but got ${args.length} arguments`);\n  return hasPlainObject;\n} // Ensures that the value is an array\n\nexport function ensureArray(value) {\n  if (Array.isArray(value)) return value;\n  return value ? [value] : [];\n} // Joins the arrays into a single array\n\nexport function joinArrays(arrays) {\n  return [].concat(...arrays);\n} // Ensures the value is an RDF/JS term\n\nexport function valueToTerm(value) {\n  switch (typeof value) {\n    // strings\n    case 'string':\n      return literal(value);\n    // booleans\n\n    case 'boolean':\n      return value ? xsdTrue : xsdFalse;\n    // numbers\n\n    case 'number':\n      if (Number.isInteger(value)) return literal(value.toString(), xsdIntegerTerm);else if (Number.isFinite(value)) return literal(value.toString(), xsdDecimalTerm);else if (value === Infinity) return xsdInf;else if (value === -Infinity) return xsdMinusInf;\n      return xsdNaN;\n    // other objects\n\n    default:\n      if (value) {\n        // RDF/JS Term\n        if (typeof value.termType === 'string') return value; // Date\n\n        if (value instanceof Date) return literal(value.toISOString(), xsdDateTimeTerm);\n      }\n\n  } // invalid objects\n\n\n  throw new Error(`Invalid object: ${value}`);\n} // Converts the term into a primitive value\n\nexport function termToPrimitive(term) {\n  const {\n    termType,\n    value\n  } = term; // Some literals convert into specific primitive values\n\n  if (termType === 'Literal') {\n    const datatype = term.datatype.value;\n\n    if (datatype.startsWith(xsd)) {\n      switch (datatype) {\n        case xsdBoolean:\n          return value === 'true' || value === '1';\n\n        case xsdInteger:\n          return Number.parseInt(value, 10);\n\n        case xsdDecimal:\n          return Number.parseFloat(value);\n\n        case xsdDouble:\n        case xsdFloat:\n          if (value in xsdPrimitives) return xsdPrimitives[value];\n          return Number.parseFloat(value);\n\n        case xsdDateTime:\n          return new Date(Date.parse(value));\n\n        default:\n      }\n    }\n  } // All other nodes convert to their value\n\n\n  return value;\n}","import ContextProvider from './ContextProvider';\nimport { lazyThenable } from './promiseUtils';\nimport { valueToTerm } from './valueUtils';\n/**\n * Resolves property names of a path\n * to their corresponding IRIs through a JSON-LD context.\n * @abstract\n */\n\nexport default class AbstractPathResolver {\n  get _context() {\n    return this._contextProvider._context;\n  }\n\n  async extendContext() {\n    await this._contextProvider.extendContext(...arguments);\n  }\n  /**\n   * Creates a new resolver for the given context(s).\n   * @param arg Either a context provider *or* a context\n   */\n\n\n  constructor(arg) {\n    this._contextProvider = new ContextProvider();\n\n    for (var _len = arguments.length, contexts = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      contexts[_key - 1] = arguments[_key];\n    }\n\n    if (arg instanceof ContextProvider) {\n      this._contextProvider = arg;\n      this.extendContext(...contexts);\n    } else {\n      this.extendContext(arg, ...contexts);\n    }\n  }\n  /**\n   * The JSON-LD resolver supports all string properties.\n   */\n\n\n  supports(property) {\n    return typeof property === 'string';\n  }\n  /**\n   * When resolving a JSON-LD or complex path property,\n   * we create a new chainable path segment corresponding to the predicate.\n   *\n   * Example usage: person.friends.firstName\n   */\n\n\n  resolve(property, pathData) {\n    const predicate = lazyThenable(() => this.expandProperty(property));\n    const reverse = lazyThenable(() => this._context.then(_ref => {\n      let {\n        contextRaw\n      } = _ref;\n      return contextRaw[property] && contextRaw[property]['@reverse'];\n    }));\n    const resultsCache = this.getResultsCache(pathData, predicate, reverse);\n    const newData = {\n      property,\n      predicate,\n      resultsCache,\n      reverse,\n      apply: this.apply\n    };\n    return pathData.extendPath(newData);\n  }\n  /**\n   * When the property is called as a function,\n   * it adds property-object constraints to the path.\n   *\n   * Example usage: person.friends.location(place).firstName\n   */\n\n\n  apply(args, pathData, path) {\n    if (args.length === 0) {\n      const {\n        property\n      } = pathData;\n      throw new Error(`Specify at least one term when calling .${property}() on a path`);\n    } // With the property constraint added, continue from the previous path\n\n\n    pathData.values = args.map(valueToTerm);\n    return path;\n  }\n\n  async expandProperty(property) {\n    // JavaScript requires keys containing colons to be quoted,\n    // so prefixed names would need to written as path['foaf:knows'].\n    // We thus allow writing path.foaf_knows or path.foaf$knows instead.\n    return this.lookupProperty(property.replace(/^([a-z][a-z0-9]*)[_$]/i, '$1:'));\n  }\n  /**\n   * Gets the results cache for the given predicate.\n   */\n\n\n  getResultsCache(pathData, predicate, reverse) {\n    let {\n      propertyCache\n    } = pathData;\n    return propertyCache && lazyThenable(async () => {\n      // Preloading does not work with reversed predicates\n      propertyCache = !(await reverse) && (await propertyCache);\n      return propertyCache && propertyCache[(await predicate).value];\n    });\n  }\n\n}","import { Util as ContextUtil } from 'jsonld-context-parser';\nimport { namedNode } from '@rdfjs/data-model';\nimport AbstractPathResolver from './AbstractPathResolver';\n/**\n * Resolves property names of a path\n * to their corresponding IRIs through a JSON-LD context.\n */\n\nexport default class JSONLDResolver extends AbstractPathResolver {\n  /**\n   * Expands a JSON property key into a full IRI.\n   */\n  async lookupProperty(property) {\n    const context = await this._context;\n    const expandedProperty = context.expandTerm(property, true);\n    if (!ContextUtil.isValidIri(expandedProperty)) throw new Error(`The JSON-LD context cannot expand the '${property}' property`);\n    return namedNode(expandedProperty);\n  }\n\n}","import AbstractPathResolver from 'ldflex/module/AbstractPathResolver';\n\n/**\n * This is a mutilated version of the LDflex ComplexPathResolver.\n * Because of this our LDflex paths may not support certain features.\n */\nexport default class ComplexPathResolver extends AbstractPathResolver {\n  supports(property) {\n    return super.supports(property) && /((^|[/|])[\\^])|(([a-z:>)])[*+?])|([)>*+?]|[a-z]*[:][a-z]*)[|/]([<(^]|[a-z]*[:][a-z]*)|(((^[(<])|([)>]$)))/i.test(property);\n  }\n\n  async lookupProperty(property) {\n    if (\n      property.startsWith('<') && property.endsWith('>') && property.split('<').length === 2) {\n        return { termType: 'namedNode', value: property.substring(1).substring(0, property.length - 2) };\n      }\n\n    try {\n      return {\n        termType: 'path',\n        value: property\n      };\n    } catch (e) {\n      throw new Error(`The Complex Path Resolver cannot expand the '${property}' path`);\n    }\n  }\n\n}","import { iteratorFor } from './iterableUtils';\n/**\n * AsyncIterator handler that yields either the subject or all results.\n *\n * Requires:\n *  - (optional) a subject on the path data\n *  - (optional) a subject on the path proxy\n *  - (optional) results on the path proxy\n */\n\nexport default class AsyncIteratorHandler {\n  handle(_ref, pathProxy) {\n    let {\n      subject\n    } = _ref;\n    // Return a one-item iterator of the subject if present;\n    // otherwise, return all results of this path\n    return subject ? () => iteratorFor(pathProxy.subject) : () => pathProxy.results[Symbol.asyncIterator]();\n  }\n\n}","// Creates a handler from the given function\nexport function handler(handle) {\n  return {\n    handle\n  };\n}","import { handler } from './handlerUtil';\nconst RDF = 'http://www.w3.org/1999/02/22-rdf-syntax-ns#';\n/**\n * @returns An handler that returns an RDF list as an array\n */\n\nexport function listHandler() {\n  return handler((_, path) => async () => {\n    let _path = await path;\n\n    const list = [];\n\n    while (_path && _path.value !== `${RDF}nil`) {\n      list.push(_path[`${RDF}first`]);\n      _path = await _path[`${RDF}rest`];\n    }\n\n    return (await Promise.all(list)).filter(value => value !== undefined);\n  });\n}\n/**\n * @param {Boolean} set Emits set if True, array otherwise\n * @returns An handler that returns an RDF collection as an array or set\n */\n\nexport function containerHandler(set) {\n  return handler((_, path) => async () => {\n    let container = [];\n    let elem;\n    let count = 0; // eslint-disable-next-line no-cond-assign\n\n    while (elem = await path[`${RDF}_${++count}`]) container.push(elem);\n\n    container = await Promise.all(container);\n    return set ? new Set(container) : container;\n  });\n}\n/**\n * @returns An handler that returns an RDF collection according to its RDF:type\n */\n\nexport function collectionHandler() {\n  return handler((pathData, path) => async () => {\n    var _await$path$;\n\n    // TODO: Handle cases where multiple classes may be present (e.g. if inferencing is on)\n    switch ((_await$path$ = await path[`${RDF}type`]) === null || _await$path$ === void 0 ? void 0 : _await$path$.value) {\n      case `${RDF}List`:\n        return listHandler().handle(pathData, path)();\n\n      case `${RDF}Bag`:\n        return containerHandler(true).handle(pathData, path)();\n\n      case `${RDF}Alt`:\n      case `${RDF}Seq`:\n      case `${RDF}Container`:\n        return containerHandler(false).handle(pathData, path)();\n\n      default:\n        // In this case none of the appropriate containers apply\n        return path;\n    }\n  });\n}","/**\n * Resolves to the given item in the path data.\n * For example, new DataHandler({}, 'foo', 'bar')\n * will return pathData.foo.bar.\n *\n * Resolution can optionally be async,\n * and/or be behind a function call.\n */\nexport default class DataHandler {\n  constructor(options) {\n    this._isAsync = options.async;\n    this._isFunction = options.function;\n\n    for (var _len = arguments.length, dataProperties = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      dataProperties[_key - 1] = arguments[_key];\n    }\n\n    this._dataProperties = dataProperties;\n  }\n\n  static sync() {\n    for (var _len2 = arguments.length, dataProperties = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      dataProperties[_key2] = arguments[_key2];\n    }\n\n    return new DataHandler({\n      async: false\n    }, ...dataProperties);\n  }\n\n  static syncFunction() {\n    for (var _len3 = arguments.length, dataProperties = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n      dataProperties[_key3] = arguments[_key3];\n    }\n\n    return new DataHandler({\n      async: false,\n      function: true\n    }, ...dataProperties);\n  }\n\n  static async() {\n    for (var _len4 = arguments.length, dataProperties = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n      dataProperties[_key4] = arguments[_key4];\n    }\n\n    return new DataHandler({\n      async: true\n    }, ...dataProperties);\n  }\n\n  static asyncFunction() {\n    for (var _len5 = arguments.length, dataProperties = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {\n      dataProperties[_key5] = arguments[_key5];\n    }\n\n    return new DataHandler({\n      async: true,\n      function: true\n    }, ...dataProperties);\n  } // Resolves the data path, or returns a function that does so\n\n\n  handle(pathData) {\n    return !this._isFunction ? this._resolveDataPath(pathData) : () => this._resolveDataPath(pathData);\n  } // Resolves the data path\n\n\n  _resolveDataPath(data) {\n    return !this._isAsync ? this._resolveSyncDataPath(data) : this._resolveAsyncDataPath(data);\n  } // Resolves synchronous property access\n\n\n  _resolveSyncDataPath(data) {\n    for (const property of this._dataProperties) data = data && data[property];\n\n    return data;\n  } // Resolves asynchronous property access\n\n\n  async _resolveAsyncDataPath(data) {\n    for (const property of this._dataProperties) data = data && (await data[property]);\n\n    return data;\n  }\n\n}","import { lazyThenable } from './promiseUtils';\nimport { iterableToArray } from './iterableUtils';\nimport { ensureArray, joinArrays, valueToTerm, hasPlainObjectArgs, isAsyncIterable } from './valueUtils';\n/**\n * Returns a function that, when called with arguments,\n * extends the path with mutationExpressions.\n *\n * Mutation functions can be called in two equivalent ways:\n * - path.property.set(object, object)\n * - path.set({ property: [object, object] })\n * Objects can be strings, terms, or path expressions.\n * The second syntax allows setting multiple properties at once.\n * It also has `null` and `undefined` as shortcuts for the empty array,\n * and a direct value as shortcut for a single-valued array.\n *\n * Requires:\n * - a pathExpression property on the path proxy and all non-raw arguments.\n */\n\nexport default class MutationFunctionHandler {\n  constructor(mutationType, allowZeroArgs) {\n    this._mutationType = mutationType;\n    this._allowZeroArgs = allowZeroArgs;\n  } // Creates a function that performs a mutation\n\n\n  handle(pathData, path) {\n    var _this = this;\n\n    return function () {\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n\n      // Check if the given arguments are valid\n      if (!_this._allowZeroArgs && !args.length) throw new Error('Mutation cannot be invoked without arguments'); // Create a lazy Promise to the mutation expressions\n\n      const mutationExpressions = lazyThenable(() => _this.createMutationExpressions(pathData, path, args));\n      return pathData.extendPath({\n        mutationExpressions\n      });\n    };\n  } // Creates expressions that represent the requested mutation\n\n\n  async createMutationExpressions(pathData, path, args) {\n    // The mutation targets a single property on the path by passing objects\n    if (!hasPlainObjectArgs(args)) return [await this.createMutationExpression(pathData, path, args)]; // The mutation targets multiple properties through a map of property-objects pairs\n\n    const pairs = Object.entries(args[0]);\n    const expressions = await Promise.all(pairs.map(_ref => {\n      let [property, values] = _ref;\n      return this.createMutationExpression(pathData, path[property], ensureArray(values));\n    })); // Group expressions together to maintain the same structure as the singular case\n    // (All properties have the same parent path, and hence the same condition)\n\n    return [expressions.length === 0 ? {} : { ...expressions[0],\n      predicateObjects: joinArrays(expressions.map(e => e.predicateObjects))\n    }];\n  } // Creates an expression that represents a mutation with the given objects\n\n\n  async createMutationExpression(pathData, path, values) {\n    // Obtain the path segments, which are the selection conditions for the mutation\n    const conditions = await path.pathExpression;\n    if (!Array.isArray(conditions)) throw new Error(`${pathData} has no pathExpression property`);\n    if (conditions.length < 2) throw new Error(`${pathData} should at least contain a subject and a predicate`); // Obtain the predicate and target objects\n\n    const {\n      predicate,\n      reverse\n    } = conditions[conditions.length - 1];\n    if (!predicate) throw new Error(`Expected predicate in ${pathData}`);\n    const objects = await this.extractObjects(pathData, path, values); // Create a mutation, unless no objects are affected (`null` means all)\n\n    return objects !== null && objects.length === 0 ? {} : {\n      mutationType: this._mutationType,\n      conditions: conditions.slice(0, -1),\n      predicateObjects: [{\n        predicate,\n        reverse,\n        objects\n      }]\n    };\n  } // Extracts individual objects from a set of values passed to a mutation function\n\n\n  async extractObjects(pathData, path, values) {\n    // If no specific values are specified, match all (represented by `null`)\n    if (values.length === 0) return null; // Otherwise, expand singular values, promises, and paths\n\n    const objects = [];\n\n    for (const value of values) {\n      if (!isAsyncIterable(value)) // Add a (promise to) a single value\n        objects.push(await value); // Add multiple values from a path\n      else objects.push(...(await iterableToArray(value)));\n    }\n\n    return objects.map(valueToTerm);\n  }\n\n}","/**\n * Executes the query represented by a path.\n *\n * Requires:\n * - a queryEngine property in the path settings\n * - a sparql property on the path proxy\n * - (optional) a resultsCache property on the path data\n */\nexport default class ExecuteQueryHandler {\n  async *handle(pathData, path) {\n    // Try to retrieve the result from cache\n    const resultsCache = await pathData.resultsCache;\n\n    if (resultsCache) {\n      for (const result of resultsCache) yield result;\n\n      return;\n    } // Retrieve the query engine and query\n\n\n    const {\n      queryEngine\n    } = pathData.settings;\n    if (!queryEngine) throw new Error(`${pathData} has no queryEngine setting`);\n    const query = await path.sparql;\n    if (query === null || query === undefined) throw new Error(`${pathData} has no sparql property`); // No results if the query is empty\n\n    if (query.length === 0) return; // Extract the term from every query result\n\n    for await (const bindings of queryEngine.execute(query)) yield this.extractTerm(bindings, pathData);\n  }\n  /**\n   * Extracts the first term from a query result binding as a new path.\n   */\n\n\n  extractTerm(binding, pathData) {\n    // Extract the first term from the binding map\n    if (binding.size !== 1) throw new Error('Only single-variable queries are supported');\n    const subject = binding.values().next().value; // Each result is a new path that starts from the term as subject\n\n    return pathData.extendPath({\n      subject\n    }, null);\n  }\n\n}","import { isPlainObject, isAsyncIterable } from './valueUtils';\nimport { iterableToArray } from './iterableUtils';\n/**\n * Returns a function that requests the values of multiple properties.\n * You can use this function to access properties as follows:\n * - fn() returns []\n * - fn(p1) returns [path[p1]]\n * - fn(p1, p2) returns [path[p1], path[p2]]\n * - fn([p1, p2]) returns [path[p1], path[p2]]\n * - fn(asyncIterable) returns [path[p1], path[p2]]\n * - fn({ p1: null, p2: null }) returns { p1: path[p1], p2: path[p2] }\n * Combinations of the above are possible by passing them in arrays.\n */\n\nexport default class GetFunctionHandler {\n  handle(pathData, path) {\n    var _this = this;\n\n    return function () {\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n\n      return _this.readProperties(path, args.length === 1 ? args[0] : args, true);\n    };\n  }\n\n  async readProperties(path, properties) {\n    let wrapSingleValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    // Convert an async iterable to an array\n    if (isAsyncIterable(properties)) properties = await iterableToArray(properties); // If passed an array, read every property\n\n    if (Array.isArray(properties)) {\n      const values = properties.map(p => this.readProperties(path, p));\n      return Promise.all(values);\n    } // If passed an object with property names as keys,\n    // return an object with the values filled in\n\n\n    if (isPlainObject(properties)) {\n      // Use the key as property value if none is specified\n      const keys = Object.keys(properties);\n      properties = keys.map(key => properties[key] || key); // Store the resolved properties by key\n\n      const results = {};\n      const values = await this.readProperties(path, properties);\n\n      for (let i = 0; i < keys.length; i++) results[keys[i]] = values[i];\n\n      return results;\n    } // Otherwise, perform a single property access\n\n\n    const value = path[properties];\n    return wrapSingleValues ? [value] : value;\n  }\n\n}","/**\n * Traverses a path to collect mutationExpressions into an expression.\n * This is needed because mutations can be chained.\n *\n * Requires:\n * - a mutationExpressions property on the path proxy\n */\nexport default class MutationExpressionsHandler {\n  async handle(pathData) {\n    const mutationExpressions = []; // Add all mutationExpressions to the path\n\n    let current = pathData;\n\n    while (current) {\n      // Obtain and store mutationExpressions\n      if (current.mutationExpressions) mutationExpressions.unshift(...(await current.mutationExpressions)); // Move to parent link\n\n      current = current.parent;\n    }\n\n    return mutationExpressions;\n  }\n\n}","/**\n * Traverses a path to collect links and nodes into an expression.\n */\nexport default class PathExpressionHandler {\n  async handle(pathData) {\n    const segments = [];\n    let current = pathData; // Add all predicates to the path\n\n    while (current.parent) {\n      // Obtain and store predicate\n      if (current.predicate) {\n        segments.unshift({\n          predicate: await current.predicate,\n          reverse: await current.reverse,\n          sort: current.sort,\n          values: current.values\n        });\n      } // Move to parent link\n\n\n      current = current.parent;\n    } // Add the root subject to the path\n\n\n    if (!current.subject) throw new Error(`Expected root subject in ${current}`);\n    const subject = await current.subject;\n    segments.unshift({\n      subject\n    });\n    return segments;\n  }\n\n}","/**\n * Returns a new path starting from the predicate of the current path.\n *\n * Requires:\n * - (optional) a predicate property on the path data\n */\nexport default class PredicateHandler {\n  handle(pathData) {\n    const {\n      predicate\n    } = pathData;\n    return !predicate ? undefined : Promise.resolve(predicate).then(subject => pathData.extendPath({\n      subject\n    }, null));\n  }\n\n}","/**\n * Queries for all predicates of a path subject\n */\nexport default class PredicatesHandler {\n  handle(pathData) {\n    return pathData.extendPath({\n      distinct: true,\n      select: '?predicate',\n      finalClause: queryVar => `${queryVar} ?predicate ?object.`,\n      property: pathData.property\n    });\n  }\n\n}","const VARIABLE = /(SELECT\\s+)(\\?\\S+)/;\nconst QUERY_TAIL = /\\}[^}]*$/;\n/**\n * Returns a function that preloads and caches\n * certain properties of results on the current path.\n *\n * Requires:\n * - a predicate handler on the path proxy\n * - a queryEngine property in the path settings\n *\n * Creates:\n * - a resultsCache property on the path data\n */\n\nexport default class PreloadHandler {\n  /**\n   * Creates a preload function.\n   */\n  handle(pathData, pathProxy) {\n    var _this = this;\n\n    return async function () {\n      for (var _len = arguments.length, properties = new Array(_len), _key = 0; _key < _len; _key++) {\n        properties[_key] = arguments[_key];\n      }\n\n      if (properties.length > 0) {\n        // Map the properties to predicates\n        const predicates = await Promise.all(properties.map(async p => (await pathProxy[p].predicate).value)); // Create and attach the results cache to the path data\n\n        pathData.resultsCache = await _this.createResultsCache(predicates, pathData, pathProxy);\n      }\n\n      return pathProxy;\n    };\n  }\n  /**\n   * Creates a cache for the results of\n   * resolving the given predicates against the path.\n   */\n\n\n  async createResultsCache(predicates, pathData, path) {\n    // Execute the preloading query\n    const {\n      query,\n      vars,\n      resultVar\n    } = await this.createQuery(predicates, path);\n    const {\n      settings: {\n        queryEngine\n      }\n    } = pathData;\n    const bindings = queryEngine.execute(query); // Extract all results and their preloaded property values\n\n    const resultsCache = {};\n    const propertyCaches = {};\n\n    for await (const binding of bindings) {\n      // Initialize the result's cache if needed\n      const result = binding.get(resultVar),\n            hash = hashTerm(result);\n\n      if (!(hash in resultsCache)) {\n        // Create the property cache\n        const propertyCache = propertyCaches[hash] = {};\n\n        for (const predicate of predicates) propertyCache[predicate] = []; // Create the result path\n\n\n        const resultData = {\n          subject: result,\n          propertyCache\n        };\n        resultsCache[hash] = pathData.extendPath(resultData, null);\n      } // Create and cache a possible property value path from the binding\n\n\n      const propertyCache = propertyCaches[hash];\n\n      for (let i = 0; i < vars.length; i++) {\n        const value = binding.get(vars[i]);\n\n        if (value) {\n          const valuePath = pathData.extendPath({\n            subject: value\n          }, null);\n          propertyCache[predicates[i]].push(valuePath);\n        }\n      }\n    }\n\n    return Object.values(resultsCache);\n  }\n  /**\n   * Creates the query for preloading the given predicates on the path\n   */\n\n\n  async createQuery(predicates, path) {\n    // Obtain the query for the current path, and its main variable\n    const parentQuery = await path.sparql;\n    const variableMatch = VARIABLE.exec(parentQuery);\n    if (!variableMatch) throw new Error(`Unexpected path query: ${parentQuery}`);\n    const resultVar = variableMatch[2]; // Modify the query to include the preload clauses\n    // TODO: instead of query manipulation, adjust the query generator\n    // TODO: support reverse predicates\n\n    const vars = predicates.map((p, i) => `?preload_${i}`);\n    const preloadClauses = predicates.map((predicate, i) => `    { ${resultVar} <${predicate}> ${vars[i]}. }`).join('\\n    UNION\\n');\n    const query = parentQuery.replace(VARIABLE, `$1$2 ${vars.join(' ')}`).replace(QUERY_TAIL, `  OPTIONAL {\\n${preloadClauses}\\n  }\\n$&`);\n    return {\n      query,\n      vars,\n      resultVar\n    };\n  }\n\n} // Returns a unique string representation of the term\n\nfunction hashTerm(term) {\n  const {\n    termType,\n    value\n  } = term;\n\n  switch (termType) {\n    case 'NamedNode':\n      return value;\n\n    case 'Literal':\n      const {\n        language,\n        datatype\n      } = term;\n      return `${termType}|${language}|${datatype.value}|${value}`;\n\n    default:\n      return `${termType}|${value}`;\n  }\n}","/**\n * Queries for all compacted predicates of a path subject\n */\nimport { JsonLdContextNormalized } from 'jsonld-context-parser';\nimport { toIterablePromise } from './promiseUtils';\nexport default class PropertiesHandler {\n  handle(pathData, path) {\n    return toIterablePromise(this._handle(pathData, path));\n  }\n\n  async *_handle(pathData, path) {\n    const contextRaw = (await pathData.settings.parsedContext) || {};\n    const context = new JsonLdContextNormalized(contextRaw);\n\n    for await (const predicate of path.predicates) yield context.compactIri(`${await predicate}`, true);\n  }\n\n}","/**\n * Returns a function that creates a new path with the same values,\n * but sorted on the given property.\n * The function accepts multiple properties to sort on a deeper path.\n *\n * Requires:\n *  - a predicate on the path proxy\n *  - a sort function on the path proxy (for multi-property sorting)\n */\nexport default class SortHandler {\n  constructor() {\n    let order = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'ASC';\n    this.order = order;\n  }\n\n  handle(pathData, pathProxy) {\n    var _this = this;\n\n    return function () {\n      for (var _len = arguments.length, properties = new Array(_len), _key = 0; _key < _len; _key++) {\n        properties[_key] = arguments[_key];\n      }\n\n      // Do nothing if no sort properties were given\n      if (properties.length === 0) return pathProxy; // Split off the first sort property and obtain its predicate\n\n      const [property, ...rest] = properties;\n      const {\n        predicate\n      } = pathProxy[property]; // Sort on the first property, and create paths for the next one\n\n      const childData = {\n        property,\n        predicate,\n        sort: _this.order\n      };\n      const childPath = pathData.extendPath(childData);\n      return rest.length === 0 ? childPath : childPath.sort(...rest);\n    };\n  }\n\n}","import { namedNode } from '@rdfjs/data-model';\nconst NEEDS_ESCAPE = /[\"\\\\\\t\\n\\r\\b\\f\\u0000-\\u0019\\ud800-\\udbff]/,\n      ESCAPE_ALL = /[\"\\\\\\t\\n\\r\\b\\f\\u0000-\\u0019]|[\\ud800-\\udbff][\\udc00-\\udfff]/g,\n      ESCAPED_CHARS = {\n  '\\\\': '\\\\\\\\',\n  '\"': '\\\\\"',\n  '\\t': '\\\\t',\n  '\\n': '\\\\n',\n  '\\r': '\\\\r',\n  '\\b': '\\\\b',\n  '\\f': '\\\\f'\n};\n/**\n * Expresses a path or mutation as a SPARQL query.\n *\n * Requires:\n * - a mutationExpressions or pathExpression property on the path proxy\n */\n\nexport default class SparqlHandler {\n  async handle(pathData, path) {\n    // First check if we have a mutation expression\n    const mutationExpressions = await path.mutationExpressions;\n    if (Array.isArray(mutationExpressions) && mutationExpressions.length) // Remove empty results to prevent dangling semicolons\n      return mutationExpressions.map(e => this.mutationExpressionToQuery(e)).filter(Boolean).join('\\n;\\n'); // Otherwise, fall back to checking for a path expression\n\n    const pathExpression = await path.pathExpression;\n    if (!Array.isArray(pathExpression)) throw new Error(`${pathData} has no pathExpression property`);\n    return this.pathExpressionToQuery(pathData, path, pathExpression);\n  }\n\n  pathExpressionToQuery(pathData, path, pathExpression) {\n    if (pathExpression.length < 2 && !pathData.finalClause) throw new Error(`${pathData} should at least contain a subject and a predicate`); // Create triple patterns\n\n    let queryVar = '?subject',\n        sorts = [],\n        clauses = [];\n\n    if (pathExpression.length > 1) {\n      queryVar = this.createVar(pathData.property);\n      ({\n        queryVar,\n        sorts,\n        clauses\n      } = this.expressionToTriplePatterns(pathExpression, queryVar));\n    }\n\n    if (pathData.finalClause) clauses.push(pathData.finalClause(queryVar)); // Create SPARQL query body\n\n    const distinct = pathData.distinct ? 'DISTINCT ' : '';\n    const select = `SELECT ${distinct}${pathData.select ? pathData.select : queryVar}`;\n    const where = ` WHERE {\\n  ${clauses.join('\\n  ')}\\n}`;\n    const orderClauses = sorts.map(_ref => {\n      let {\n        order,\n        variable\n      } = _ref;\n      return `${order}(${variable})`;\n    });\n    const orderBy = orderClauses.length === 0 ? '' : `\\nORDER BY ${orderClauses.join(' ')}`;\n    return `${select}${where}${orderBy}`;\n  }\n\n  mutationExpressionToQuery(_ref2) {\n    let {\n      mutationType,\n      conditions,\n      predicateObjects\n    } = _ref2;\n    // If there are no mutations, there is no query\n    if (!mutationType || !conditions || predicateObjects && predicateObjects.length === 0) return ''; // Create the WHERE clauses\n\n    const scope = {};\n    let subject, where; // If the only condition is a subject, we need no WHERE clause\n\n    if (conditions.length === 1) {\n      subject = this.termToString(conditions[0].subject);\n      where = [];\n    } // Otherwise, create a WHERE clause from all conditions\n    else {\n      const lastPredicate = conditions[conditions.length - 1].predicate;\n      subject = this.createVar(lastPredicate.value, scope);\n      ({\n        queryVar: subject,\n        clauses: where\n      } = this.expressionToTriplePatterns(conditions, subject, scope));\n    } // Create the mutation clauses\n\n\n    const mutations = [];\n\n    for (const {\n      predicate,\n      reverse,\n      objects\n    } of predicateObjects) {\n      // Mutate either only the specified objects, or all of them\n      const objectStrings = objects ? objects.map(o => this.termToString(o)) : [this.createVar(predicate.value, scope)]; // Generate a triple pattern for all subjects\n\n      mutations.push(...this.triplePatterns(subject, predicate, objectStrings, reverse));\n    }\n\n    const mutationClauses = `{\\n  ${mutations.join('\\n  ')}\\n}`; // Join clauses into a SPARQL query\n\n    return where.length === 0 ? // If there are no WHERE clauses, just mutate raw data\n    `${mutationType} DATA ${mutationClauses}` : // Otherwise, return a DELETE/INSERT ... WHERE ... query\n    `${mutationType} ${mutationClauses} WHERE {\\n  ${where.join('\\n  ')}\\n}`;\n  }\n\n  expressionToTriplePatterns(_ref3, lastVar) {\n    let [root, ...pathExpression] = _ref3;\n    let scope = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    const lastIndex = pathExpression.length - 1;\n    const clauses = [];\n    const sorts = [];\n    let object = this.termToString(skolemize(root.subject));\n    let queryVar = object;\n    let allowValues = false;\n    pathExpression.forEach((segment, index) => {\n      // Obtain components and generate triple pattern\n      const subject = object;\n      const {\n        predicate,\n        reverse,\n        sort,\n        values\n      } = segment; // Use fixed object values values if they were specified\n\n      let objects;\n\n      if (values && values.length > 0) {\n        if (!allowValues) throw new Error('Specifying fixed values is not allowed here');\n        objects = values.map(this.termToString);\n        allowValues = false; // disallow subsequent fixed values for this predicate\n      } // Otherwise, use a variable subject\n      else {\n        object = index < lastIndex ? this.createVar(`v${index}`, scope) : lastVar;\n        objects = [object];\n        allowValues = true;\n      }\n\n      clauses.push(...this.triplePatterns(subject, predicate, objects, reverse)); // If the sort option was not set, use this object as a query variable\n\n      if (!sort) {\n        queryVar = object;\n      } // If sort was set, use this object as a sorting variable\n      else {\n        // TODO: handle when an object is used for sorting, and later also for querying\n        sorts.push({\n          variable: object,\n          order: sort\n        }); // TODO: use a descriptive lastVar in case of sorting\n\n        object = queryVar;\n      }\n    });\n    return {\n      queryVar,\n      sorts,\n      clauses\n    };\n  } // Creates a unique query variable within the given scope, based on the suggestion\n\n\n  createVar() {\n    let suggestion = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n    let scope = arguments.length > 1 ? arguments[1] : undefined;\n    let counter = 0;\n    let label = `?${suggestion.match(/[a-z0-9]*$/i)[0] || 'result'}`;\n\n    if (scope) {\n      suggestion = label;\n\n      while (scope[label]) label = `${suggestion}_${counter++}`;\n\n      scope[label] = true;\n    }\n\n    return label;\n  } // Converts an RDFJS term to a string that we can use in a query\n\n\n  termToString(term) {\n    // Determine escaped value\n    let {\n      value\n    } = term;\n    if (NEEDS_ESCAPE.test(value)) value = value.replace(ESCAPE_ALL, escapeCharacter);\n\n    switch (term.termType) {\n      case 'NamedNode':\n        return `<${value}>`;\n\n      case 'BlankNode':\n        return `_:${value}`;\n\n      case 'Literal':\n        // Determine optional language or datatype\n        let suffix = '';\n        if (term.language) suffix = `@${term.language}`;else if (term.datatype.value !== 'http://www.w3.org/2001/XMLSchema#string') suffix = `^^<${term.datatype.value}>`;\n        return `\"${value}\"${suffix}`;\n\n      default:\n        throw new Error(`Could not convert a term of type ${term.termType}`);\n    }\n  } // Creates triple patterns for the given subject, predicate, and objects\n\n\n  triplePatterns(subjectString, predicateTerm, objectStrings) {\n    let reverse = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n    let subjectStrings = [subjectString];\n    if (reverse) [subjectStrings, objectStrings] = [objectStrings, subjectStrings];\n    const objects = objectStrings.join(', ');\n    const predicate = predicateTerm.termType === 'path' ? predicateTerm.value : `<${predicateTerm.value}>`;\n    return subjectStrings.map(s => `${s} ${predicate} ${objects}.`);\n  }\n\n} // Replaces a character by its escaped version\n// (borrowed from https://www.npmjs.com/package/n3)\n\nfunction escapeCharacter(character) {\n  // Replace a single character by its escaped version\n  let result = ESCAPED_CHARS[character];\n\n  if (result === undefined) {\n    // Replace a single character with its 4-bit unicode escape sequence\n    if (character.length === 1) {\n      result = character.charCodeAt(0).toString(16);\n      result = '\\\\u0000'.substr(0, 6 - result.length) + result;\n    } // Replace a surrogate pair with its 8-bit unicode escape sequence\n    else {\n      result = ((character.charCodeAt(0) - 0xD800) * 0x400 + character.charCodeAt(1) + 0x2400).toString(16);\n      result = '\\\\U00000000'.substr(0, 10 - result.length) + result;\n    }\n  }\n\n  return result;\n} // Skolemizes the given term if it is a blank node\n\n\nlet skolemId = 0;\n\nfunction skolemize(term) {\n  if (term.termType !== 'BlankNode') return term;\n  if (!term.skolemized) term.skolemized = namedNode(`urn:ldflex:sk${skolemId++}`);\n  return term.skolemized;\n}","/**\n * Yields a function that interprets a string expression as an LDflex path.\n */\nexport default class StringToLDflexHandler {\n  handle(pathData, path) {\n    // Resolves the given string expression against the LDflex object\n    return function () {\n      let expression = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n      let ldflex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : path;\n      // An expression starts with a property access in dot or bracket notation\n      const propertyPath = expression // Add brackets around a single URL\n      .replace(/^(https?:\\/\\/[^()[\\]'\"]+)$/, '[\"$1\"]') // Add the starting dot if omitted\n      .replace(/^(?=[a-z$_])/i, '.') // Add quotes inside of brackets if omitted\n      .replace(/\\[([^'\"`\\](]*)\\]/g, '[\"$1\"]'); // Create a function to evaluate the expression\n\n      const body = `\"use strict\";return ldflex${propertyPath}`;\n      let evaluator;\n\n      try {\n        /* eslint no-new-func: off */\n        evaluator = Function('ldflex', body);\n      } catch ({\n        message\n      }) {\n        throw new Error(`Expression \"${expression}\" is invalid: ${message}`);\n      } // Evaluate the function\n\n\n      return evaluator(ldflex);\n    };\n  }\n\n}","/**\n * Returns a new path starting from the subject of the current path.\n *\n * Requires:\n * - (optional) a subject property on the path data\n * - (optional) a parent property on the path data\n */\nexport default class SubjectHandler {\n  handle(pathData) {\n    // Traverse parents until we find a subject\n    let {\n      subject,\n      parent\n    } = pathData;\n\n    while (!subject && parent) ({\n      subject,\n      parent\n    } = parent); // Resolve the subject if it exists,\n    // and return a path starting from that subject\n\n\n    return !subject ? undefined : Promise.resolve(subject).then(value => pathData.extendPath({\n      subject: value\n    }, null));\n  }\n\n}","/**\n * Queries for all subjects of a document\n */\nexport default class SubjectsHandler {\n  handle(pathData) {\n    return pathData.extendPath({\n      distinct: true,\n      select: '?subject',\n      finalClause: () => '?subject ?predicate ?object.',\n      property: pathData.property\n    });\n  }\n\n}","import { getThen } from './promiseUtils';\nimport { getFirstItem } from './iterableUtils';\n/**\n * Thenable handler that resolves to either the subject\n * of the first item of the results.\n *\n * Requires:\n *  - (optional) a subject on the path data\n *  - (optional) a subject on the path proxy\n *  - (optional) results on the path proxy\n */\n\nexport default class ThenHandler {\n  handle(_ref, pathProxy) {\n    let {\n      subject\n    } = _ref;\n    // Resolve to either the subject (zero-length path) or the first result\n    return subject ? // If the subject is not a promise, it has already been resolved;\n    // consumers should not resolve it, but access its properties directly.\n    // This avoids infinite `then` chains when `await`ing this path.\n    subject.then && getThen(() => pathProxy.subject) : // Otherwise, return the first result of this path\n    getThen(() => getFirstItem(pathProxy.results));\n  }\n\n}","import { isAsyncIterable } from './valueUtils';\n/**\n * Converts an asynchronously iterable path into an array.\n *\n * Requires:\n * - (optional) an iterable path\n */\n\nexport default class ToArrayHandler {\n  handle(pathData, path) {\n    return async map => {\n      const items = [];\n\n      if (isAsyncIterable(path)) {\n        // Ensure the mapping function is valid\n        if (typeof map !== 'function') map = item => item; // Retrieve and map all elements\n\n        let index = 0;\n\n        for await (const item of path) items.push(await map(item, index++));\n      }\n\n      return items;\n    };\n  }\n\n}","import { handler } from './handlerUtil';\n/**\n * Finds the index at which the break between the namespace and the\n * occurs - then execute a callback with this index as the second arg\n */\n\nfunction breakIndex(term, cb) {\n  if ((term === null || term === void 0 ? void 0 : term.termType) !== 'NamedNode') return undefined; // Find the index of the last '#' or '/' if no '#' exists\n\n  const hashIndex = term.value.lastIndexOf('#');\n  return cb(term.value, hashIndex === -1 ? term.value.lastIndexOf('/') : hashIndex);\n}\n/**\n * Gets the namespace of a NamedNode subject\n */\n\n\nexport const namespaceHandler = handler(_ref => {\n  let {\n    subject\n  } = _ref;\n  return breakIndex(subject, (str, index) => str.slice(0, index + 1));\n});\n/**\n * Gets the fragment of a NamedNode subject\n */\n\nexport const fragmentHandler = handler(_ref2 => {\n  let {\n    subject\n  } = _ref2;\n  return breakIndex(subject, (str, index) => str.slice(index + 1));\n});\n/**\n * Gets the prefix of a NamedNode subject\n */\n\nexport const prefixHandler = handler(async data => {\n  const context = await data.settings.parsedContext;\n  const ns = namespaceHandler.handle(data);\n\n  for (const key in context) {\n    if (typeof key === 'string' && context[key] === ns) return key;\n  }\n\n  return undefined;\n});","import AsyncIteratorHandler from './AsyncIteratorHandler';\nimport { listHandler, containerHandler, collectionHandler } from './CollectionsHandler';\nimport DataHandler from './DataHandler';\nimport DeleteFunctionHandler from './DeleteFunctionHandler';\nimport ExecuteQueryHandler from './ExecuteQueryHandler';\nimport GetHandler from './GetFunctionHandler';\nimport InsertFunctionHandler from './InsertFunctionHandler';\nimport MutationExpressionsHandler from './MutationExpressionsHandler';\nimport PathExpressionHandler from './PathExpressionHandler';\nimport PredicateHandler from './PredicateHandler';\nimport PredicatesHandler from './PredicatesHandler';\nimport PreloadHandler from './PreloadHandler';\nimport PropertiesHandler from './PropertiesHandler';\nimport ReplaceFunctionHandler from './ReplaceFunctionHandler';\nimport SetFunctionHandler from './SetFunctionHandler';\nimport SortHandler from './SortHandler';\nimport SparqlHandler from './SparqlHandler';\nimport StringToLDflexHandler from './StringToLDflexHandler';\nimport SubjectHandler from './SubjectHandler';\nimport SubjectsHandler from './SubjectsHandler';\nimport ThenHandler from './ThenHandler';\nimport ToArrayHandler from './ToArrayHandler';\nimport { termToPrimitive } from './valueUtils';\nimport { handler } from './handlerUtil';\nimport { prefixHandler, namespaceHandler, fragmentHandler } from './URIHandler';\n/**\n * A map with default property handlers.\n */\n\nexport default {\n  // Flag to loaders that exported paths are not ES6 modules\n  __esModule: () => undefined,\n  // Add thenable and async iterable behavior\n  then: new ThenHandler(),\n  [Symbol.asyncIterator]: new AsyncIteratorHandler(),\n  // Add utilities for collections\n  list: listHandler(),\n  container: containerHandler(false),\n  containerAsSet: containerHandler(true),\n  collection: collectionHandler(),\n  // Add read and query functionality\n  get: new GetHandler(),\n  subject: new SubjectHandler(),\n  predicate: new PredicateHandler(),\n  properties: new PropertiesHandler(),\n  predicates: new PredicatesHandler(),\n  pathExpression: new PathExpressionHandler(),\n  sparql: new SparqlHandler(),\n  subjects: new SubjectsHandler(),\n  results: new ExecuteQueryHandler(),\n  sort: new SortHandler('ASC'),\n  sortDesc: new SortHandler('DESC'),\n  preload: new PreloadHandler(),\n  // Add write functionality\n  mutationExpressions: new MutationExpressionsHandler(),\n  add: new InsertFunctionHandler(),\n  set: new SetFunctionHandler(),\n  replace: new ReplaceFunctionHandler(),\n  delete: new DeleteFunctionHandler(),\n  // Add RDFJS term handling\n  termType: termPropertyHandler('termType'),\n  value: termPropertyHandler('value'),\n  datatype: termPropertyHandler('datatype'),\n  language: termPropertyHandler('language'),\n  canonical: termPropertyHandler('canonical'),\n  equals: DataHandler.sync('subject', 'equals'),\n  toString: DataHandler.syncFunction('subject', 'value'),\n  valueOf: subjectToPrimitiveHandler(),\n  toPrimitive: subjectToPrimitiveHandler(),\n  // URI / namedNode handling\n  prefix: prefixHandler,\n  namespace: namespaceHandler,\n  fragment: fragmentHandler,\n  // Add iteration helpers\n  toArray: new ToArrayHandler(),\n  termTypes: handler((_, path) => path.toArray(term => term.termType)),\n  values: handler((_, path) => path.toArray(term => term.value)),\n  datatypes: handler((_, path) => path.toArray(term => term.datatype)),\n  languages: handler((_, path) => path.toArray(term => term.language)),\n  // Parse a string into an LDflex object\n  resolve: new StringToLDflexHandler()\n}; // Creates a handler for the given RDF/JS Term property\n\nfunction termPropertyHandler(property) {\n  // If a resolved subject is present,\n  // behave as an RDF/JS term and synchronously expose the property;\n  // otherwise, return a promise to the property value\n  return handler((_ref, path) => {\n    let {\n      subject\n    } = _ref;\n    return subject && property in subject ? subject[property] : path.then && path.then(term => term === null || term === void 0 ? void 0 : term[property]);\n  });\n} // Creates a handler that converts the subject into a primitive\n\n\nfunction subjectToPrimitiveHandler() {\n  return handler(_ref2 => {\n    let {\n      subject\n    } = _ref2;\n    return () => typeof (subject === null || subject === void 0 ? void 0 : subject.termType) !== 'string' ? undefined : termToPrimitive(subject);\n  });\n}","import MutationFunctionHandler from './MutationFunctionHandler';\n/**\n * A MutationFunctionHandler for insertions.\n */\n\nexport default class InsertFunctionHandler extends MutationFunctionHandler {\n  constructor() {\n    super('INSERT', false);\n  }\n\n}","import MutationFunctionHandler from './MutationFunctionHandler';\nimport { hasPlainObjectArgs } from './valueUtils';\n/**\n * Returns a function that deletes all existing values\n * for the path, and then adds the given values to the path.\n *\n * Requires:\n * - a delete function on the path proxy.\n * - an add function on the path proxy.\n */\n\nexport default class SetFunctionHandler extends MutationFunctionHandler {\n  handle(pathData, path) {\n    return function () {\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n\n      // First, delete all existing values for the property/properties\n      const deletePath = !hasPlainObjectArgs(args) ? // When a single property is given, delete all of its values\n      path.delete() : // When a map of properties is given, delete all of their values\n      Object.keys(args[0]).reduce((previousPath, property) => previousPath.delete({\n        [property]: []\n      }), path); // Next, insert the new values\n\n      return deletePath.add(...args);\n    };\n  }\n\n}","/**\n * Returns a function that deletes the given value\n * for the path, and then adds the given values to the path.\n *\n * Requires:\n * - a delete function on the path proxy.\n * - an add function on the path proxy.\n */\nexport default class ReplaceFunctionHandler {\n  handle(pathData, path) {\n    return function (oldValue) {\n      for (var _len = arguments.length, newValues = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        newValues[_key - 1] = arguments[_key];\n      }\n\n      if (!oldValue || !newValues.length) throw new Error('Replacing values requires at least two arguments, old value followed by all new values');\n      return path.delete(oldValue).add(...newValues);\n    };\n  }\n\n}","import MutationFunctionHandler from './MutationFunctionHandler';\n/**\n * A MutationFunctionHandler for deletions.\n */\n\nexport default class DeleteFunctionHandler extends MutationFunctionHandler {\n  constructor() {\n    super('DELETE', true);\n  }\n\n}","import PathProxy from 'ldflex/module/PathProxy';\nimport JSONLDResolver from 'ldflex/module/JSONLDResolver';\nimport ComplexPathResolver from './ComplexPathResolver';\nimport defaultHandlers from 'ldflex/module/defaultHandlers';\nimport { ContextParser } from 'jsonld-context-parser';\nimport ContextProvider from 'ldflex/module/ContextProvider';\n/**\n * A PathFactory creates paths with default settings.\n */\n\nexport default class PathFactory {\n\n  private _settings: any\n  private _data: any\n  private _jsonldResolver: any\n  private _pathProxy: any\n\n  constructor(settings, data) {\n    // Store settings and data\n    this._settings = settings = { ...settings\n    };\n    this._data = data = { ...data\n    }; // Prepare the handlers\n\n    const handlers = settings.handlers || defaultHandlers;\n\n    for (const key in handlers) handlers[key] = toHandler(handlers[key]);\n\n    for (const key of Object.getOwnPropertySymbols(handlers)) handlers[key] = toHandler(handlers[key]); // Prepare the resolvers\n\n\n    const resolvers = (settings.resolvers || []).map(toResolver);\n\n    if (settings.context) {\n      const contextProvider = new ContextProvider(settings.context);\n      resolvers.push(new ComplexPathResolver(contextProvider));\n      resolvers.push(this._jsonldResolver = new JSONLDResolver(contextProvider));\n      settings.parsedContext = new ContextParser().parse(settings.context).then(_ref => {\n        let {\n          contextRaw\n        } = _ref;\n        return contextRaw;\n      });\n    } else {\n      settings.context = settings.parsedContext = {};\n    } // Instantiate PathProxy that will create the paths\n\n\n    this._pathProxy = new PathProxy({\n      handlers,\n      resolvers\n    }); // Remove PathProxy settings from the settings object\n\n    delete settings.handlers;\n    delete settings.resolvers;\n  }\n  /**\n   * Creates a path with the given (optional) settings and data.\n   */\n\n\n  create() {\n    let settings = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    let data = arguments.length > 1 ? arguments[1] : undefined;\n    // The settings parameter is optional\n    if (!data) [data, settings] = [settings, null]; // Set data as subject if input as string\n\n    if (typeof data === 'string') data = {\n      subject: data\n    }; // Apply defaults on data\n\n    const _data = { ...this._data,\n      ...data\n    }; // Resolve string subjects to namedNodes\n\n    if (typeof _data.subject === 'string') {\n      if (this._jsonldResolver) _data.subject = this._jsonldResolver.lookupProperty(_data.subject);else throw new Error('Unable to resolve string subject - try providing a context to the PathFactory');\n    } // Apply defaults on settings\n\n\n    return this._pathProxy.createPath({ ...this._settings,\n      ...settings\n    }, _data);\n  }\n\n}\nPathFactory.defaultHandlers = defaultHandlers;\n/**\n * Converts a handler function into a handler object.\n */\n\nexport function toHandler(handle) {\n  return typeof handle.handle === 'function' ? handle : {\n    handle\n  };\n}\n/**\n * Converts a resolver function into a catch-all resolver object.\n */\n\nexport function toResolver(resolve) {\n  return typeof resolve.resolve === 'function' ? resolve : {\n    supports,\n    resolve\n  };\n} // Catch-all resolvers support everything\n\nfunction supports() {\n  return true;\n}","/**\n * Asynchronous iterator wrapper for the Comunica SPARQL query engine.\n */\nexport default class FetchEngine {\n\n  private source: string\n\n  constructor (source: string) {\n    this.source = source\n  }\n\n  /**\n   * Creates an asynchronous iterable of results for the given SPARQL query.\n   */\n  async* execute(query: string) {\n    const url = new URL(this.source)\n    url.searchParams.set('format', 'application/sparql-results+json')\n    const data = new FormData()\n    data.set('query', query)\n    const response = await fetch(url.toString(), {\n      method: 'POST',\n      body: data,\n    })\n\n    const json = await response.json()\n    const { results: { bindings } } = json\n\n    for (const binding of bindings) {\n      yield new Proxy(binding, {\n        get (target, name) {\n          if (name === 'get') {\n            return (variable) => binding[variable]\n          }\n        }\n      })\n    }\n  }\n}\n","const VARIABLE = /(SELECT\\s+)(\\?\\S+)/;\nconst QUERY_TAIL = /\\}[^}]*$/;\n\n/**\n * Returns a function that preloads and caches\n * certain properties of results on the current path.\n *\n * Requires:\n * - a predicate handler on the path proxy\n * - a queryEngine property in the path settings\n *\n * Creates:\n * - a resultsCache property on the path data\n */\n\nexport default class PreloadHandler {\n  /**\n   * Creates a preload function.\n   */\n  handle(pathData, pathProxy) {\n    var _this = this;\n\n    return async function () {\n      for (var _len = arguments.length, properties = new Array(_len), _key = 0; _key < _len; _key++) {\n        properties[_key] = arguments[_key];\n      }\n\n      if (properties.length > 0) {\n        // Map the properties to predicates\n        const predicates = await Promise.all(properties.map(async p => (await pathProxy[p].predicate).value)); // Create and attach the results cache to the path data\n\n        pathData.resultsCache = await _this.createResultsCache(predicates, pathData, pathProxy);\n      }\n\n      return pathProxy;\n    };\n  }\n  /**\n   * Creates a cache for the results of\n   * resolving the given predicates against the path.\n   */\n\n\n  async createResultsCache(predicates, pathData, path) {\n    // Execute the preloading query\n    const {\n      query,\n      vars,\n      resultVar\n    } = await this.createQuery(predicates, path);\n    // console.log(query)\n    const {\n      settings: {\n        queryEngine\n      }\n    } = pathData;\n    const bindings = queryEngine.execute(query); // Extract all results and their preloaded property values\n\n    const resultsCache = {};\n    const propertyCaches = {};\n\n    for await (const binding of bindings) {\n      // Initialize the result's cache if needed\n      const result = binding.get(resultVar.substring(1)),\n            hash = hashTerm(result);\n\n      if (!(hash in resultsCache)) {\n        // Create the property cache\n        const propertyCache = propertyCaches[hash] = {};\n\n        for (const predicate of predicates) propertyCache[predicate] = []; // Create the result path\n\n\n        const resultData = {\n          subject: result,\n          propertyCache\n        };\n        resultsCache[hash] = pathData.extendPath(resultData, null);\n      } // Create and cache a possible property value path from the binding\n\n\n      const propertyCache = propertyCaches[hash];\n\n      for (let i = 0; i < vars.length; i++) {\n        const value = binding.get(vars[i].substring(1));\n\n        if (value) {\n          const valuePath = pathData.extendPath({\n            subject: value\n          }, null);\n          propertyCache[predicates[i]].push(valuePath);\n        }\n      }\n    }\n\n    return Object.values(resultsCache);\n  }\n  \n  /**\n   * Creates the query for preloading the given predicates on the path\n   */\n  async createQuery(predicates, path) {\n    // Obtain the query for the current path, and its main variable\n    const parentQuery = await path.sparql;\n    const variableMatch = VARIABLE.exec(parentQuery);\n    if (!variableMatch) throw new Error(`Unexpected path query: ${parentQuery}`);\n    const resultVar = variableMatch[2]; // Modify the query to include the preload clauses\n    // TODO: instead of query manipulation, adjust the query generator\n    // TODO: support reverse predicates\n\n    const vars = predicates.map((p, i) => `?preload_${i}`);\n    const preloadClauses = predicates.map((predicate, i) => `    { ${resultVar} ${predicate.startsWith('http') ? `<${predicate}>` : predicate} ${vars[i]}. }`).join('\\n    UNION\\n');\n    const query = parentQuery.replace(VARIABLE, `$1$2 ${vars.join(' ')}`).replace(QUERY_TAIL, `  OPTIONAL {\\n${preloadClauses}\\n  }\\n$&`);\n    return {\n      query,\n      vars,\n      resultVar\n    };\n  }\n\n} // Returns a unique string representation of the term\n\nfunction hashTerm(term) {\n  const {\n    termType,\n    value\n  } = term;\n\n  switch (termType) {\n    case 'NamedNode':\n      return value;\n\n    case 'Literal':\n      const {\n        language,\n        datatype\n      } = term;\n      return `${termType}|${language}|${datatype.value}|${value}`;\n\n    default:\n      return `${termType}|${value}`;\n  }\n}","import PathFactory from './PathFactory'\nimport FetchEngine from './FetchEngine'\nimport PreloadHandler from './PreloadHandler'\nimport AsyncIteratorHandler from 'ldflex/module/AsyncIteratorHandler';\nimport { listHandler, containerHandler, collectionHandler } from 'ldflex/module/CollectionsHandler';\nimport DataHandler from 'ldflex/module/DataHandler';\nimport ExecuteQueryHandler from 'ldflex/module/ExecuteQueryHandler';\nimport GetHandler from 'ldflex/module/GetFunctionHandler';\nimport MutationExpressionsHandler from 'ldflex/module/MutationExpressionsHandler';\nimport PathExpressionHandler from 'ldflex/module/PathExpressionHandler';\nimport PredicateHandler from 'ldflex/module/PredicateHandler';\nimport PredicatesHandler from 'ldflex/module/PredicatesHandler';\nimport PropertiesHandler from 'ldflex/module/PropertiesHandler';\nimport SortHandler from 'ldflex/module/SortHandler';\nimport SparqlHandler from 'ldflex/module/SparqlHandler';\nimport StringToLDflexHandler from 'ldflex/module/StringToLDflexHandler';\nimport SubjectHandler from 'ldflex/module/SubjectHandler';\nimport SubjectsHandler from 'ldflex/module/SubjectsHandler';\nimport ThenHandler from 'ldflex/module/ThenHandler';\nimport ToArrayHandler from 'ldflex/module/ToArrayHandler';\nimport { termToPrimitive } from 'ldflex/module/valueUtils';\nimport { handler } from 'ldflex/module/handlerUtil';\nimport { prefixHandler, namespaceHandler, fragmentHandler } from 'ldflex/module/URIHandler';\n/**\n * A map with default property handlers.\n */\n\nconst defaultHandlers = {\n  // Flag to loaders that exported paths are not ES6 modules\n  __esModule: () => undefined,\n  // Add thenable and async iterable behavior\n  then: new ThenHandler(),\n  [Symbol.asyncIterator]: new AsyncIteratorHandler(),\n  // Add utilities for collections\n  list: listHandler(),\n  container: containerHandler(false),\n  containerAsSet: containerHandler(true),\n  collection: collectionHandler(),\n  // Add read and query functionality\n  get: new GetHandler(),\n  subject: new SubjectHandler(),\n  predicate: new PredicateHandler(),\n  properties: new PropertiesHandler(),\n  predicates: new PredicatesHandler(),\n  pathExpression: new PathExpressionHandler(),\n  sparql: new SparqlHandler(),\n  subjects: new SubjectsHandler(),\n  results: new ExecuteQueryHandler(),\n  sort: new SortHandler('ASC'),\n  sortDesc: new SortHandler('DESC'),\n  preload: new PreloadHandler(),\n  // Add write functionality\n  mutationExpressions: new MutationExpressionsHandler(),\n  // Add RDFJS term handling\n  termType: termPropertyHandler('termType'),\n  value: termPropertyHandler('value'),\n  datatype: termPropertyHandler('datatype'),\n  language: termPropertyHandler('language'),\n  canonical: termPropertyHandler('canonical'),\n  equals: DataHandler.sync('subject', 'equals'),\n  toString: DataHandler.syncFunction('subject', 'value'),\n  valueOf: subjectToPrimitiveHandler(),\n  toPrimitive: subjectToPrimitiveHandler(),\n  // URI / namedNode handling\n  prefix: prefixHandler,\n  namespace: namespaceHandler,\n  fragment: fragmentHandler,\n  // Add iteration helpers\n  toArray: new ToArrayHandler(),\n  termTypes: handler((_, path) => path.toArray(term => term.termType)),\n  values: handler((_, path) => path.toArray(term => term.value)),\n  datatypes: handler((_, path) => path.toArray(term => term.datatype)),\n  languages: handler((_, path) => path.toArray(term => term.language)),\n  // Parse a string into an LDflex object\n  resolve: new StringToLDflexHandler()\n}; // Creates a handler for the given RDF/JS Term property\n\nfunction termPropertyHandler(property) {\n  // If a resolved subject is present,\n  // behave as an RDF/JS term and synchronously expose the property;\n  // otherwise, return a promise to the property value\n  return handler((_ref, path) => {\n    let {\n      subject\n    } = _ref;\n    return subject && property in subject ? subject[property] : path.then && path.then(term => term === null || term === void 0 ? void 0 : term[property]);\n  });\n} // Creates a handler that converts the subject into a primitive\n\n\nfunction subjectToPrimitiveHandler() {\n  return handler(_ref2 => {\n    let {\n      subject\n    } = _ref2;\n    return () => typeof (subject === null || subject === void 0 ? void 0 : subject.termType) !== 'string' ? undefined : termToPrimitive(subject);\n  });\n}\n\nclass ParentHandler {\n  handle(pathData) {\n    let node = pathData\n    while (node.parent) node = node.parent\n    return node\n  }\n}\n\nclass PathHandler {\n  handle(pathData) {\n     return pathData\n  }\n}\n\nexport const map = {\n  handle: (pathData, path) => {\n    return async (callback) => {\n      const result = []\n      \n      const innerPredicates = []\n\n      const tester = new Proxy({}, {\n        get(target, property, receiver) {\n          innerPredicates.push(property)\n          return Reflect.get(target, property, receiver)\n        }\n      })\n\n      callback(tester)\n\n      await path.preload(innerPredicates)\n\n      for await (const subPath of path) {\n        result.push(callback(subPath))\n      }\n\n      return result  \n    }\n  }\n}\n\nconst handlers = {\n  ...defaultHandlers,\n\n  parent: new ParentHandler(),\n  path: new PathHandler(),\n  preload: new PreloadHandler(),\n  map\n}\n\nexport const path = (iri: string, prefixes, vocab?: string, source?: string, extraLDflexHandlers: { [key: string]: any } = {}) => {\n  if (!source) source = iri\n  const queryEngine = new FetchEngine(source)\n  const context = { '@context': { ...prefixes }}\n  if (vocab) { context['@context']['@vocab'] = prefixes[vocab] }\n  const path = new PathFactory({ queryEngine, handlers: {\n    ...handlers,\n    ...extraLDflexHandlers\n  }, context }, undefined)\n  /** @ts-ignore */\n  return path.create({ subject: { termType: 'NamedNode', value: iri } })\n}","import { html, render, Hole } from 'uhtml'\nimport { JsonLdContextNormalized } from 'jsonld-context-parser'\nimport { foreign } from 'uhandlers'\nimport { loaders } from './withLoader'\nimport { preloadPaths } from './preloadPaths'\nimport { path } from './path'\n\nconst ldflexAttribute = (value, preloader) => foreign((node, name, value) => {\n  preloader.then(() => {\n    value.value.then(resolved => {\n      if (typeof resolved === 'string') {\n        node.setAttribute(name, resolved)\n      }  \n    })  \n  })\n}, value)\n\nexport const createHtml = (options: {\n  loader: any,\n  error: any,\n  extraLDflexHandlers?: {\n    [key: string]: any\n  },\n  dataHandlers: {\n    [key: string]: Function\n  },\n  prefixes: {\n    [key: string]: string\n  }\n}) => {\n  const parsedContext = new JsonLdContextNormalized(options.prefixes)\n  \n  for (const [type, handler] of Object.entries(options.dataHandlers)) {\n    const expandedType = parsedContext.expandTerm(type)\n    if (expandedType !== type) options.dataHandlers[expandedType] = handler\n  }\n\n  const htmlReplacement = function (templates, ...values) {\n    const paths = values.filter(value => typeof value?.extendPath === 'function')\n    const preloader = paths.length ? preloadPaths(paths) : Promise.resolve()\n\n    values = values.map((value, index) => {\n      const isAttr = templates[index].trim().endsWith('=')\n      const isLDflex = typeof value?.extendPath === 'function'\n\n      if (isAttr && isLDflex) return ldflexAttribute(value, preloader)\n      \n      return mapValue(options, value, preloader)\n    })\n\n    return html(templates, ...values)\n  }\n\n  const get = (iri, vocab = 'foaf', source = null) => path(iri, options.prefixes, vocab, source, options.extraLDflexHandlers)\n\n  return {\n    html: htmlReplacement,\n    render: render,\n    Hole,\n    get\n  }\n}\n\n\n\nconst mapValue = (options, value, preloader) => {\n  const isLDflex = typeof value?.extendPath === 'function'\n  const isPromise = value instanceof Promise\n\n  if (!isLDflex && !isPromise) return value\n\n  // Return an uHTML interpolate callback.\n  return (comment) => {\n    const parentNode = comment.parentNode\n\n    if (parentNode && parentNode instanceof HTMLElement) {\n      render(parentNode, loaders.get(value) ?? options.loader())\n\n      if (isPromise && !isLDflex) {\n        return value.then(resolved => render(parentNode, html`${resolved}`))\n      }\n\n      if (isLDflex) {\n        return preloader.then(() => value.then(async resolved => {\n          const type = await (resolved?.datatype)?.id ?? 'iri'\n          const valueValue = await resolved?.value  \n\n          if (!valueValue) return parentNode.innerHTML = ''\n\n          if (!options.dataHandlers[type]) throw new Error('Missing data handler: ' + type)\n          return render(parentNode, options.dataHandlers[type](valueValue))  \n        })).catch((exception) => {\n          render(parentNode, options.error(exception))\n        })\n      }\n    }\n  }\n}","import { createHtml, prefixes } from '../src/index'\n\nexport const { html, render, Hole, get: getter } = createHtml({\n  loader: () => html`Loading...`,\n  error: (exception) => html``,\n  prefixes,\n  dataHandlers: {\n    'rdf:langString': (value) => value,\n    'xsd:string': (value) => value,\n    'xsd:date': (value) => new Date(value).toLocaleString('nl', { dateStyle: 'short' }),\n    'iri': (string: string) => {\n      if (string.includes('mailto:')) {\n        return html`<a href=${string}>${string.replace('mailto:', '')}</a>`\n      }\n      return string\n    }\n  }\n})\n\nconst get = (url) => getter(url, 'dbo', 'https://dbpedia.org/sparql')\n\nconst philosopherUrls = [\n  'Søren_Kierkegaard',\n  'Friedrich_Nietzsche',\n  'Immanuel_Kant',\n  'Plato',\n  'Aristotle'\n].map(id => `http://dbpedia.org/resource/${id}`)\n\nconst philosopherData = philosopherUrls.map(url => [get(url), url])\n\nconst draw = () => {\n  render(document.body, html`\n    <div class=\"container pt-5\">\n    <h1>A demonstration of <a target=\"_blank\" href=\"https://github.com/danielbeeke/uhtml-ldflex\">uHTML-LDflex</a></h1>\n\n    <p>\n      What are you seeing <a target=\"_blank\" href=\"https://github.com/danielbeeke/uhtml-ldflex/blob/master/demo/demo.ts\">here</a>?\n\n      <ul>\n      <li>uHTML templating engine, that automatically resolves LDflex paths via type specific handlers.</li>\n      <li>Multiple calls inside a template are bundled into one query via the preload function of LDflex.</li>\n      <li>The query bundling also works for .map(). A custom LDflex handler is written for that use case.</li>\n      <li>Promises first show a preloader and then are shown.</li>\n      <li>Dont mind the different languages, the demonstration is here to show fetching.</li>\n      </ul>\n    </p>\n\n    <div class=\"row row-cols-1 row-cols-md-5 g-4\">\n      ${philosopherData.map(([person, url]) => html`\n      <div class=\"col\">\n        <div class=\"card\">\n          <img src=${person.thumbnail} class=\"card-img-top\" alt=${person.label}>\n          <div class=\"card-body\">\n            <h5 class=\"card-title\">\n              <span>${person.label}</span>\n            </h5>\n            <em>✝<span>${person.deathYear}</span></em>\n\n            <p class=\"card-text truncate\">${person.rdfs_comment}</p>\n            <a href=${url} target=\"_blank\" class=\"btn btn-primary\">Read more</a>\n          </div>\n        </div>\n      </div>\n      `)}\n    </div>\n\n  </div>\n  `)\n}\n\ndraw()\n","export default {\n  schema: 'https://schema.org/',\n  foaf: 'http://xmlns.com/foaf/0.1/',\n  rdf: 'http://www.w3.org/1999/02/22-rdf-syntax-ns#',\n  dbo: 'http://dbpedia.org/ontology/',\n  dbr: 'http://dbpedia.org/resource/',\n  dbp: 'http://dbpedia.org/property/',\n  rdfs: 'http://www.w3.org/2000/01/rdf-schema#',\n\n  \"friends\": \"knows\",\n  \"label\": \"http://www.w3.org/2000/01/rdf-schema#label\",\n}"],"names":["Object","defineProperty","module","exports","value","defaultExpandOptions","ContextParser","$d5badd2c26ab9273$var$ContextParser","constructor","options","this","documentLoader","$bETwV","FetchDocumentLoader","documentCache","validateContext","skipValidation","expandContentTypeToBase","remoteContextsDepthLimit","redirectSchemaOrgHttps","static","strictRange","errorCode","$60GtF","ErrorCoded","JSON","stringify","$daggI","Util","REGEX_LANGUAGE_TAG","test","strictValues","ERROR_CODES","INVALID_BASE_DIRECTION","REGEX_DIRECTION_TAG","idifyReverseTerms","context","key","keys","isValidKeyword","INVALID_IRI_MAPPING","isPotentialKeyword","expandPrefixedTerms","contextRaw","getContextRaw","EXPAND_KEYS_BLACKLIST","indexOf","isReservedInternalKeyword","keyValue","ALIAS_DOMAIN_BLACKLIST","KEYWORD_REDEFINITION","ALIAS_RANGE_BLACKLIST","getContextValueId","INVALID_KEYWORD_ALIAS","INVALID_TERM_DEFINITION","isPrefixValue","changed","expandTerm","id","type","canAddIdEntry","isValidIri","newId","normalize","processingMode","normalizeLanguageTags","toLowerCase","containersToHash","Array","isArray","newValue","containerValue","applyScopedProtected","isTermProtected","validateKeywordRedefinitions","contextBefore","contextAfter","expandOptions","isPrefix","isSimpleTermDefinitionPrefix","valueBefore","$kRKFi","PROTECTED_TERM_REDEFINITION","validate","valueType","substr","INVALID_VOCAB_MAPPING","INVALID_BASE_IRI","validateLanguage","INVALID_DEFAULT_LANGUAGE","INVALID_VERSION_VALUE","validateDirection","INVALID_CONTEXT_ENTRY","INVALID_PROPAGATE_VALUE","getPrefix","CYCLIC_IRI_MAPPING","isValidIriWeak","$ecGDU","JsonLdContextNormalized","isCompactIri","objectKey","objectValue","INVALID_TYPE_MAPPING","INVALID_REVERSE_PROPERTY","length","CONTAINERS_1_0","join","INVALID_CONTAINER_MAPPING","CONTAINERS","INVALID_LANGUAGE_MAPPING","INVALID_PREFIX_VALUE","INVALID_NEST_VALUE","applyBaseEntry","inheritFromParent","parentContext","baseIRI","external","$7vqNZ","resolve","normalizeContextIri","contextIri","_a","Error","startsWith","async","ignoreScopedContexts","assign","parse","ignoreProtection","ignoreRemoteScopedContexts","e","message","INVALID_SCOPED_CONTEXT","minimalProcessing","parentContextInitial","DEFAULT_PROCESSING_MODE","remoteContexts","CONTEXT_OVERFLOW","hasProtectedTerms","INVALID_CONTEXT_NULLIFICATION","overriddenLoad","getOverriddenLoad","parsedStringContext","load","contextIris","contexts","Promise","all","map","subContext","i","reducedContexts","reduce","accContextPromise","contextEntry","then","accContext","newContext","importContext","INVALID_IMPORT_VALUE","loadImportContext","newContextWrapped","parseInnerContexts","INVALID_LOCAL_CONTEXT","url","cached","slice","document","LOADING_REMOTE_CONTEXT_FAILED","INVALID_REMOTE_CONTEXT","RECURSIVE_CONTEXT_INCLUSION","importContextIri","allowPrefixForcing","allowPrefixNonGenDelims","allowVocabRelativeToBase","m","p","hasOwnProperty","$5770389bd4da54cd$var$__export","parcelRequire","$314e59417b49fb58$var$removeDotSegments","path","segmentBuffers","$314e59417b49fb58$var$isCharacterAllowedAfterRelativePathSegment","push","pop","buffer","$314e59417b49fb58$var$removeDotSegmentsOfPath","iri","colonPosition","searchOffset","pathSeparator","character","relativeIRI","baseFragmentPos","baseQueryPos","relativeColonPos","valueColonPos","baseColonPos","baseIRIScheme","baseSlashAfterColonPos","baseIRIPath","baseIRILastSlashPos","lastIndexOf","removeDotSegments","removeDotSegmentsOfPath","$012117816057b5b7$var$ErrorCoded","code","super","fetcher","response","fetch","headers","Headers","accept","ok","mediaType","get","colonPos","json","has","alternateUrl","forEach","linkHeader","$ewyr8","link","rel","uri","LOADING_DOCUMENT_FAILED","statusText","status","$a92ec442860f76cf$var$COMPATIBLE_ENCODING_PATTERN","$a92ec442860f76cf$var$WS_TRIM_PATTERN","$a92ec442860f76cf$var$WS_CHAR_PATTERN","$a92ec442860f76cf$var$WS_FOLD_PATTERN","$a92ec442860f76cf$var$DELIMITER_PATTERN","$a92ec442860f76cf$var$WS_DELIMITER_PATTERN","$a92ec442860f76cf$var$TOKEN_PATTERN","$a92ec442860f76cf$var$STATE","$a92ec442860f76cf$var$trim","replace","$a92ec442860f76cf$var$hasWhitespace","$a92ec442860f76cf$var$skipWhitespace","offset","$a92ec442860f76cf$var$needsQuotes","$a92ec442860f76cf$var$Link","refs","links","attr","set","state","ref","expandRelations","end","attrValue","isSingleOccurenceAttr","parseExtendedValue","toString","formatAttribute","isCompatibleEncoding","isTokenAttr","escapeQuotes","split","parts","exec","language","encoding","decodeURIComponent","formatExtendedAttribute","data","toUpperCase","$a92ec442860f76cf$require$Buffer","isBuffer","encodeURIComponent","item","term","expandVocab","$ilG7L","contextValue","validIriMapping","prefix","vocab","vocabRelative","base","potentialKeyword","contextPrefixValue","value1","compactIri","shortestPrefixing","suffix","$9958d424577e20bb$var$Util","separatorPos","charAt","isPrefixIriEndingWithGenDelim","keyword","KEYWORD_REGEX","prefixIri","ENDS_WITH_GEN_DELIM","Boolean","IRI_REGEX","IRI_REGEX_WEAK","VALID_KEYWORDS","serialize","object","toJSON","t","cv","ci","undefined","sort","$bcf84813260afc6e$export$ab7b06d4df4bd22c","Map","$bcf84813260afc6e$export$7f4c745ffacc49c3","WeakMap","$61178465fdbf3d7e$var$empty","$61178465fdbf3d7e$var$elements","$61178465fdbf3d7e$var$attributes","$61178465fdbf3d7e$var$holes","$61178465fdbf3d7e$export$2e2bcd8739ae039","template","svg","trim","_","name","attrs","selfClosing","ml","trimEnd","hole","$ecc501ba0d41d67f$export$6060d40568773aeb","node","operation","nodeType","firstChild","lastChild","range","createRange","setStartAfter","setEndAfter","deleteContents","$ecc501ba0d41d67f$var$remove","valueOf","$ecc501ba0d41d67f$export$1f6005ddc92972ec","fragment","childNodes","nodes","append","$b3258917d0828e07$export$43bee75e5e14138e","$b3258917d0828e07$export$305f7d4e9d4624f2","$b3258917d0828e07$export$58adb3bec8346d0f","$7240226fe329deda$var$useForeign","$7240226fe329deda$export$53ed384e325652d1","handler","args","$7240226fe329deda$export$74ab03834501d175","$7240226fe329deda$export$4d2d26490572750a","values","removeAttribute","setAttribute","$7240226fe329deda$export$af4b9a83f4b00434","oldValue","orphan","attributeNode","createAttributeNS","removeAttributeNode","setAttributeNodeNS","$7240226fe329deda$export$4a21f16c33752377","$7240226fe329deda$export$6cd530ed55e06764","lower","info","removeEventListener","addEventListener","$7240226fe329deda$export$eff4d24c3ff7876e","current","$7240226fe329deda$export$a74fa819f7f7dff","dataset","$7240226fe329deda$export$4051a07651545597","$7240226fe329deda$export$6f093cfa640b7166","textContent","$b490468aba95cf48$export$2e2bcd8739ae039","parentNode","a","b","before","bLength","aEnd","bEnd","aStart","bStart","nextSibling","insertBefore","removeChild","node1","index","i1","sequence","node2","replaceChild","$85ceb4c4930851b9$export$43bee75e5e14138e","prototype","$85ceb4c4930851b9$var$prototype","$85ceb4c4930851b9$export$305f7d4e9d4624f2","createDocumentFragment","$85ceb4c4930851b9$var$createDocumentFragment","createElement","$85ceb4c4930851b9$var$createElement","createElementNS","$85ceb4c4930851b9$var$createElementNS","createTextNode","$85ceb4c4930851b9$export$b2ce9ad90858ed7a","createTreeWalker","$85ceb4c4930851b9$export$469f9e892a721cc4","importNode","$85ceb4c4930851b9$export$ce5e1f6513119f55","Proxy","target","method","bind","$85ceb4c4930851b9$var$xml","$85ceb4c4930851b9$export$41c7a4cacf5bab80","text","innerHTML","content","$85ceb4c4930851b9$var$createSVG","html","$85ceb4c4930851b9$var$createHTML","$330230bd5b038b08$var$reducePath","$330230bd5b038b08$var$diff","comment","oldNodes","newNodes","$330230bd5b038b08$var$handleAttribute","$330230bd5b038b08$export$455ce229eb3d2472","reduceRight","anyContent","String","$330230bd5b038b08$var$handleAnything","$8469b9cb06d7c13b$var$createPath","call","$8469b9cb06d7c13b$var$cache","$8469b9cb06d7c13b$var$textOnly","$8469b9cb06d7c13b$var$mapTemplate","tw","search","nextNode","hasAttribute","getAttribute","localName","$8469b9cb06d7c13b$var$mapUpdates","$8469b9cb06d7c13b$export$ed24ab65af38c83e","$8469b9cb06d7c13b$var$unrollValues","entry","updates","wire","$8469b9cb06d7c13b$var$createEntry","stack","$8469b9cb06d7c13b$export$b5329b670b24e23b","splice","$4e67bca1670ec494$var$tag","keyed","for","memo","cache","$4e67bca1670ec494$var$cache","$4e67bca1670ec494$export$b3890eb0ae9dca99","where","what","replaceChildren","$4e67bca1670ec494$export$c0bb0b647f701bb5","$98d3a02356f1e4e1$var$__createBinding","$98d3a02356f1e4e1$exports","__createBinding","create","o","k","k2","desc","getOwnPropertyDescriptor","__esModule","writable","configurable","enumerable","$98d3a02356f1e4e1$var$__exportStar","__exportStar","exports1","$f3ecf2feebc7a8b5$export$c1150d502d9297b5","$54e133eb8aa16a95$export$35d09263ef00f583","paths","pathSubjects","filteredPaths","filter","resultsCache","proxy","subject","pathParts1","pathExpressions","pathExpression","predicate","part","parent","finalClause","variable","preload","path1","propertyCache","exception","console","log","$b13e04ab20de0537$var$EMPTY","$b13e04ab20de0537$export$2e2bcd8739ae039","handlers","resolvers","arguments","_handlers","_resolvers","createPath","settings","apply","rawData","_len","_key","extendPath","pathProxy","newData","pathData","property","handle","resolver","supports","$c4a80bd6daf032e3$var$BlankNode","nextId","equals","other","termType","$c4a80bd6daf032e3$exports","$70d1d15a2ee48e0c$var$DefaultGraph","$70d1d15a2ee48e0c$exports","$469aaba89416fb89$exports","original","blankNode","defaultGraph","literal","namedNode","datatype","fromTerm","graph","quad","$feae462edac1a694$var$NamedNode","$feae462edac1a694$exports","$acc48dc164c2be81$var$Literal","stringDatatype","langStringDatatype","$acc48dc164c2be81$exports","$868cb1b0ea4ac746$var$Quad","$868cb1b0ea4ac746$exports","$e151f9a6a4700aa8$var$Variable","$e151f9a6a4700aa8$exports","$7c28fbf97ea5af67$var$DataFactory","languageOrDatatype","defaultGraphInstance","$d3343728b28df12c$exports","$06ddb7918055a40f$export$2e2bcd8739ae039","_context","extendContext","_ref","$f100efee839a663f$var$done","$f100efee839a663f$export$94dedbb929af3d62","iterable","items","$f100efee839a663f$export$fbdeaa6a76694f71","Symbol","asyncIterator","next","$a446f56847ecbf38$export$6d207d5e6f54a902","createPromise","$a446f56847ecbf38$export$81b5bd35a112305e","onResolved","onRejected","$a446f56847ecbf38$export$99faa5b4f68eaefc","iterator","done","$a446f56847ecbf38$export$cc5f62ee316eaef7","catch","finally","callback","$f9e7a01c3a089480$var$xsd","$f9e7a01c3a089480$var$xsdBoolean","$f9e7a01c3a089480$var$xsdDateTime","$f9e7a01c3a089480$var$xsdDecimal","$f9e7a01c3a089480$var$xsdDouble","$f9e7a01c3a089480$var$xsdFloat","$f9e7a01c3a089480$var$xsdInteger","$f9e7a01c3a089480$var$xsdBooleanTerm","$f9e7a01c3a089480$var$xsdDateTimeTerm","$f9e7a01c3a089480$var$xsdDecimalTerm","$f9e7a01c3a089480$var$xsdDoubleTerm","$f9e7a01c3a089480$var$xsdIntegerTerm","$f9e7a01c3a089480$var$xsdTrue","$f9e7a01c3a089480$var$xsdFalse","$f9e7a01c3a089480$var$xsdNaN","$f9e7a01c3a089480$var$xsdInf","$f9e7a01c3a089480$var$xsdMinusInf","$f9e7a01c3a089480$var$xsdPrimitives","NaN","INF","Infinity","$f9e7a01c3a089480$export$edb10ab8dd75a915","$f9e7a01c3a089480$export$53b83ca8eaab0383","Date","$f9e7a01c3a089480$export$b01956448ecd3bdc","allowMultiple","hasPlainObject","some","$f9e7a01c3a089480$export$8dd40c03ee9b5c3","Number","isInteger","isFinite","toISOString","$f9e7a01c3a089480$export$538f936da7b46354","parseInt","parseFloat","$127f0820467cd2e1$export$2e2bcd8739ae039","_contextProvider","arg","expandProperty","reverse","getResultsCache","lookupProperty","$1f3369ddeac50426$export$2e2bcd8739ae039","expandedProperty","$7f1d2bf42a8b78c1$export$2e2bcd8739ae039","endsWith","substring","$4113a88de52e3aa0$export$2e2bcd8739ae039","results","$46798b4bb47cd649$export$c3c52e219617878","$4ea28dfec0bd2fb2$var$RDF","$4ea28dfec0bd2fb2$export$f30c4e1edcf592e8","_path","list","$4ea28dfec0bd2fb2$export$44bea742488e990c","elem","container","count","Set","$4ea28dfec0bd2fb2$export$72904feb8709e15","_await$path$","$d7f468b0edd276fa$export$2e2bcd8739ae039","_isAsync","_isFunction","function","dataProperties","_dataProperties","_len2","_key2","_len3","_key3","_len4","_key4","_len5","_key5","_resolveDataPath","_resolveAsyncDataPath","_resolveSyncDataPath","$879ff7062d07a995$export$2e2bcd8739ae039","mutationType","allowZeroArgs","_mutationType","_allowZeroArgs","_this","mutationExpressions","createMutationExpressions","createMutationExpression","pairs","entries","expressions","predicateObjects","arrays","concat","conditions","objects","extractObjects","$e4add4ad23b90f08$export$2e2bcd8739ae039","result","queryEngine","query","sparql","bindings","execute","extractTerm","binding","size","$fa8028b2a631c3f6$export$2e2bcd8739ae039","readProperties","properties","wrapSingleValues","values1","$ed015f10b0bf1946$export$2e2bcd8739ae039","unshift","$a3b3cf70a2fef168$export$2e2bcd8739ae039","segments","$0e75bcaaec172bbb$export$2e2bcd8739ae039","$abbb8a941cfef090$export$2e2bcd8739ae039","distinct","select","queryVar","$184df34911bd2b9b$var$VARIABLE","$184df34911bd2b9b$var$QUERY_TAIL","$184df34911bd2b9b$var$hashTerm","$0f86330a8afa961f$export$2e2bcd8739ae039","_handle","parsedContext","predicates","$9f4bf2e77836e3dc$export$2e2bcd8739ae039","order","rest","childData","childPath","$cde6a1087723111d$var$NEEDS_ESCAPE","$cde6a1087723111d$var$ESCAPE_ALL","$cde6a1087723111d$var$ESCAPED_CHARS","$cde6a1087723111d$export$2e2bcd8739ae039","mutationExpressionToQuery","pathExpressionToQuery","sorts","clauses","createVar","expressionToTriplePatterns","orderClauses","_ref2","scope","termToString","lastPredicate","mutations","objectStrings","triplePatterns","mutationClauses","_ref3","lastVar","root","lastIndex","skolemized","$cde6a1087723111d$var$skolemId","$cde6a1087723111d$var$skolemize","allowValues","segment","suggestion","counter","label","match","$cde6a1087723111d$var$escapeCharacter","subjectString","predicateTerm","subjectStrings","s","charCodeAt","$f590eb3b92c01e5b$export$2e2bcd8739ae039","expression","ldflex","propertyPath","body","evaluator","Function","$7f4cb88f2df1024d$export$2e2bcd8739ae039","$274528315d5892e3$export$2e2bcd8739ae039","$a153779bd992a56c$export$2e2bcd8739ae039","$917c280a5eeda973$export$2e2bcd8739ae039","$ce4a4811e70758b2$var$breakIndex","cb","hashIndex","$ce4a4811e70758b2$export$8bfed00c3c6ef015","str","$ce4a4811e70758b2$export$3b296f2eb789ca61","$ce4a4811e70758b2$export$13cf003aeda35845","ns","$0031c953ef0a9248$export$2e2bcd8739ae039","containerAsSet","collection","subjects","sortDesc","createResultsCache","vars","resultVar","createQuery","propertyCaches","hash","resultData","propertyCache1","valuePath","parentQuery","variableMatch","preloadClauses","add","deletePath","previousPath","delete","newValues","$0031c953ef0a9248$var$termPropertyHandler","canonical","sync","syncFunction","$0031c953ef0a9248$var$subjectToPrimitiveHandler","toPrimitive","namespace","toArray","termTypes","datatypes","languages","$6fef23b5e35451d7$export$2e2bcd8739ae039","_settings","_data","$6fef23b5e35451d7$export$768ae4aa3d78e8c9","key1","getOwnPropertySymbols","$6fef23b5e35451d7$export$ee3795cd6e92e609","contextProvider","_jsonldResolver","_pathProxy","$6fef23b5e35451d7$var$supports","defaultHandlers","$f72ef8ce453d064f$export$2e2bcd8739ae039","source","URL","searchParams","FormData","$3eabb9874846a939$var$VARIABLE","$3eabb9874846a939$var$QUERY_TAIL","$3eabb9874846a939$export$2e2bcd8739ae039","$3eabb9874846a939$var$hashTerm","$bd0379e8af276cb0$var$defaultHandlers","$bd0379e8af276cb0$var$termPropertyHandler","$bd0379e8af276cb0$var$subjectToPrimitiveHandler","$bd0379e8af276cb0$export$871de8747c9eaa88","innerPredicates","receiver","Reflect","subPath","$bd0379e8af276cb0$var$handlers","$bd0379e8af276cb0$export$bb654e07daaf8c3a","prefixes","extraLDflexHandlers","$9035fcb1f82b7d78$var$ldflexAttribute","preloader","resolved","$9035fcb1f82b7d78$export$fbb6fe9928cdb676","dataHandlers","expandedType","templates","$9035fcb1f82b7d78$var$mapValue","render","isLDflex","isPromise","HTMLElement","loader","valueValue","error","$6a0b8834f5db41d3$export$c0bb0b647f701bb5","$6a0b8834f5db41d3$export$b3890eb0ae9dca99","Hole","$6a0b8834f5db41d3$export$b5329b670b24e23b","$6a0b8834f5db41d3$export$ea8d306c5e2b8884","schema","foaf","rdf","dbo","dbr","dbp","rdfs","friends","toLocaleString","dateStyle","string","includes","$6a0b8834f5db41d3$var$get","$6a0b8834f5db41d3$var$philosopherData","person","thumbnail","deathYear","rdfs_comment"],"version":3,"file":"index.3461db96.js.map"}